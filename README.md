# Journey-to-become-a-Blockchain-Engineer

I'm sharing everything I'm learning to become a Blockchain Engineer

![Blockchain](/Images/main.jpg)

| <p align="center"> [Day 1](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day1/Day1.md) </p> |
| ------ |
|  **Blockchain** |
| - Bitcoin |
| - Ethereum |
| - Smart Contracts |
| - Bitcoin Vs Ethereum |
| - Oracle Problem & Solution |
| - Hybrid Smart Contracts |
| - Chainlink |
| - Importance of Ethereum |
| - Chainlink features |
| - Summary |
| **Features of blockchain and smart contracts**|
| - Decentralized |
| - Transparency & Flexibility |
| - Speed & Efficiency |
| - Security & Immutability |
| -  Removal of Counterparty risks |
| - Trust Minimized  Agreements |
| - Summary |
|  **DAOs**|
| <p align="center"> [Day 2](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day2/Day2.md) </p> |
| **Ethereum Transaction On a Live  Blockchain** |
| - Wallet Creation |
| - Etherscan |
| - Multiple Accounts |
| - Mnemonic ,  Public & Private keys |
| - Mnemonic vs Private vs Public keys |
| - Mainnet & Testnets |
| - Initiating our first Transaction |
| - Transaction details |
| - Gas fees, Transaction fees, Gas limit, Gas price |
| - Gas vs Gas price vs Gas Limit vs Transaction fee |
| - Gas estimator |
| **How Blockchain works/whats going on Inside the Blockchain** |
| - Hash or Hashing or SHA256 |
| - Block |
| - Blockchain |
| - Decentralized/Distributed Blockchain |
| - Tokens/Transaction History |
| - Summary |
|        |
| <p align="center"> [Day 3](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day3/Day3.md) </p> |
| **Signing and Verifying a Transaction** |
| - Public & Private Keys |
| - Signatures |
| - Transactions |
| - Summary |
| **Concepts are same** |
| - Nodes |
| - Centralized entity vs  Decentralized Blockchain |
| - Transactions are Listed |
| - Consensus |
| - proof of work/Sybil resistance mechanism |
| - Blocktime |
| - Chain selection rule |
| - Nakamoto consensus |
| - Block Confirmations |
| - Block rewards & transaction fees |
| - Sybil attack |
| - 51% attack |
| - Drawbacks of pow |
| - proof of stake/sybil resistance mechanism |
| - Validators |
| - pros & cons of pos |
| - Scalability problem & Sharding solution |
| - Layer 1 & Layer 2 |
| - Rollups |
| - Summary |
| <p align="center"> [Day 4](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day4/Day4.md) </p> |
| **Solidity** |
| **Lesson 1 - Remix IDE & its features** |
| - Solidity version |
| - Defining a  Contract |
| - Variable types & Declaration |
| - Solidity Documentation |
| - Initializing |
| - Functions or methods |
| - Deploying a Contract |
| - Public , Internal , private , External Visibility |
| - Modifying a Variable |
| - Scope |
| - View functions |
| - Pure function |
| - Structs |
| - Intro to storage |
| - Arrays |
| - Dynamic array |
| - Fixed array |
| - Adding to an array |
| - Compiler Errors |
| - Memory Keyword |
| - Storage keyword |
| - Mappings Datastructure |
| - SPDX license |
| - Deploying to a live network |
| - Interacting with deployed contracts |
| - EVM |
| - Summary |
| <p align="center"> [Day 5](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day5/Day5.md) </p> |
| **Lesson 2 - StorageFactory** |
| - Factory pattern |
| - New contract StorageFactory |
| - Import 1 contract into another |
| - Deploy a Contract from a Contract |
| - Track simple storage contracts |
| - Interacting with Contract deployed Contract |
| - Calling Store & Retrieve Functions from SF |
| - Address & ABI |
| - Compiling & storing in SS through SF |
| - Adding Retrieve Function |
| - Compiling |
| - Making the Code lil bit Simpler |
| - Additional Note |
| - Inheritance |
| - Recap |
| <p align="center"> [Day 6](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day6/Day6.md) </p> |
| **Lesson 3 - Fund me** |
| - purpose of this contract |
| - Payable function , wei , gwei & ether |
| - Mapping , msg. sender , msg.value |
| - Funding |
| - ETH -> USD /conversion |
| - Deterministic problem & Oracle solution |
| - Centralized Oracles |
| - Decentralized Oracle Networks |
| - Chainlink Datafeeds |
| - Chainlink Code documentation on ETH/USD |
| - Importing Datafeed code from Chainlink NPM package |
| - Interfaces |
| - ABI/Application Binary Interface |
| - Interacting with an Interface Contract |
| - Finding the Pricefeed Address |
| - Deploying |
| - Getprice function |
| - Tuples |
| - Typecasting |
| - deploying |
| - Clearing unused Tuple Variables & Deploying |
| - Making the contract look Clean |
| - Wei/Gwei Standard (Matching Units) |
| - getting the price using Get conversion rate |
| - deploying |
| <p align="center"> [Day 7](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day7/Day7.md) </p> |
| - Safemath & Integer Overflow |
| - Libraries |
| - Setting Threshold |
| - Require statement |
| - Revert |
| - Deplying & Transaction |
| - Withdraw Function |
| - Transfer , Balance , This |
| - Deploying |
| - Owner , Constructor Function |
| - Deploying |
| - Modifiers |
| - Deploying |
| - Resetting the Funders Balances to Zero |
| - For loop |
| - Summary |
| - Deploying & Transaction |
| - Forcing a Trasacttion |
| <p align="center"> [Day 8](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day8/Day8.md) </p> |
| **Lesson 4 - Web3. py SimpleStorage** |
| - Limitations of Remix |
| - VScode , Python , Solidity Setup |
| - VScode features |
| - Testing python install & Troubleshooting |
| - Creating a new folder |
| - SimpleStorage. sol |
| - Remember to save |
| - VScode Solidity Settings |
| - Python Formatter & settings |
| - Author's recommended Settings |
| - working with python |
| - Reading our solidity file in python |
| - Running in Python |
| - Keyboard Shortcuts |
| - Py-Solc-x |
| - Importing solcx |
| - Compiled_sol |
| - Bracket pair colorized |
| - pysolcx documentation |
| - Printing Compiled_sol |
| - Comparison wih remix (Lowlevelstuffs , ABI) |
| - Saving Compiled Code/writing |
| - import Json |
| - Json formatting/settings |
| - Deploying in Python (Bytecode , ABI) |
| - Which Blockchain/Where to deploy |
| - Ganache Chain |
| - Ganache UI |
| - Introduction to Web3. py |
| - pip install web3 |
| - import web3 |
| - Http/Rpc provider |
| - Connecting to Ganache(RPC server,Documentation,Chain ID,address,Privatekey) |
| - Deploy to Ganache |
| - Building a Transaction |
| - Nonce |
| - Getting Nonce |
| - Create a Transaction |
| - Transaction Parameters |
| - Signing Our Transaction(signed_txn) |
| - Never Hardcode your Private keys |
| - Environment Variables |
| - Setting Environment variables |
| - Limitations of Exporting  Environment Variables |
| - Private key PSA |
| - Accessing Environment Variables |
| - .env file, .gitignore, pip install python-dotenv |
| - load_dotenv() |
| - Sending the signed Transaction |
| - Deployment |
| <p align="center"> [Day 9](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day9/Day9.md) </p> |
| - Block confirmation(wait_for_transaction_reciept) |
| - interact/work with thee contract |
| - Address & ABI |
| - Retrieve() , Call & Transact |
| - Store function |
| - Creating Transaction(Store_transaction) |
| - Signing Transaction(signed_store_txn) |
| - Sending Transaction(send_store_tx,tx_receipt) |
| - Deployment |
| - some nice syntax & deployment |
| - ganache-cli  |
| - install Nodejs |
| - install yarn |
| - Run ganache cli , ganache documentation |
| - update privatekeys,addresses,http provider |
| - open new terminal & deploy |
| - deploy to testnet/mainnet |
| - Infura, Alchemy |
| - Create project |
| - update the rinkeby url, Chain id ,  address &  private key |
| - Deploying |
| - summary/recap |
| <p align="center"> [Day 10](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day10/Day10.md) </p> |
| **Lesson 5 - Brownie Simple Storage** |
| - Brownie Intro & Features |
| - install Brownie |
| - 1st brownie simplestorage project |
| - Brownie Folders |
| - brownie compile & store |
| - brownie deploy |
| - brownie runscripts/deploy. py & default brownie network |
| - brownie Advantages over web3. py in deploying |
| - getting address & private key using Accounts package |
| - add default ganache account using index |
| - add accounts using Commandline |
| - add accounts using env variables |
| - adding wallets in yaml file and updating in account |
| - importing contract simplestorage |
| - importing & deploying in brownie vs web3. py |
| - recreating web3 .py script in brownie |
| - tests |
| - Deploying to a Testnet |
| - Brownie console |
| <p align="center"> [Day 11](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day11/Day11.md) </p> |
| **Lesson 6 -Brownie Fund Me** |
| - Initial Setup |
| - Dependencies |
| - Remappings |
| - Rinkeby Deploy Script |
| - init.py |
| - Deploying to Rinkeby |
| - Deploying to ganache |
| - Mock |
| - Constructor Parameters |
| <p align="center"> [Day 12](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day12/Day12.md) </p> |
| - Refactoring |
| - Deploying to a persistant ganache |
| - Adding network to brownie |
| - Withdraw and Fund |
| - Testing |
| - Default Network |
| - Mainnet fork |
| - Custom mainnet-fork |
| - Adding to Github |
| - Where should I run my tests? |
| <p align="center"> [Day 13](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day13/Day13.md) </p> |
| **Lesson 7: SmartContract Lottery** |
| - Decentralized Lottery |
| - Setup |
| - Wait..is this really decentralized? |
| - Could we make it decentralized? |
| - Chainlink Keepers |
| - Lottery.sol |
| - Main functions of Lottery.sol |
| - address payable[] |
| - require minimum payment |
| - getEntranceFee |
| - Testing |
| - Enum |
| - startLottery |
| - Randomness |
| - pseudorandom numbers |
| - True Randomness with Chainlink VRF |
| - Oracle Gas and Transaction Gas |
| - Request and Receive |
| - Kovan |
| - Gas Estimation Failed |
| - After Link transaction completes |
| - After transaction completes |
| - Request and Receive |
| - Asynchronous 2 Transactions |
| - Clarification |
| <p align="center"> Day 14 </p> |
| - endLottery |
| - returns(type variableName) |
| - fulfillRandomness |
| - override |
| - Modulo(Mod Operation %) |
| - Lottery Testing |
| - deploy_lottery.py |
| - get_account refactored |
| - contract_to_mock |
| - Contract.from_abi |
| - Adding vrfCoordinatorMock |
| - Start Lottery |
| - enter_lottery |
| - end_lottery |
| - Funding with LINK |
| - brownie interfaces |
| - waiting for callback |
| - Integration Tests Vs Unit Tests |
| - Unit Testing |
| - pytest.skip |
| - test_cant_enter_unless_started |
| - test_can_start_and_enter_lottery |
| - test_can_end_lottery |
| - test_can_pick_winner_correctly |
| - Events and Logs |
| - callBackWithRandomness |
| - Integration Test |
| - Test deployment |
| - Topics |
| - Conftest.py |
| <p align="center"> Day 15 </p> |
| **Lesson 8: Chainlink Mix** |
| **Lesson 9: ERC20s, EIPs, and Token Standards** |
| - Why make an ERC20? |
| - How do we build one of these tokens? |
| - Solidity 0.8 |
| - 1_deploy_token.py |
| <p align="center"> Day 16 </p> |
| **Lesson 10: Defi & Aave** |
| - Decentralized Exchange(DEX) |
| - Depositing tokens/ Lending |
| - WETHGateway |
| - Interest Bearing Token (aToken) |
| - Why borrow? |
| - Stable Vs Variable Interest Rate |
| - Reward token / Governance token |
| - Programmatic interactions with Aave |
| - Qunt Defi Engineer |
| - No contract deployments here |
| - aave_borrow.py |
| - Converting ETH -> WETH |
| - Get the WETH interface |
| - Why not get_contract? |
| <p align="center"> Day 17 </p> |
| - aave_borrow.py |
| - Lending Pool |
| - LendingPool Address Provider |
| - Fixing Importing Dependencies |
| - deposit function |
| - getUserAccountData |
| - liquidation threshold |
| - Getting DAI conversion rate |
| - Aave Testnet Token Addresses |
| - Repaying |
| - Testing |

 
## Lesson 8: Chainlink Mix

That was a lot of stuff to code and quite frankly I don't think any of us want to have to do that every single time have to code everything from scratch.There's actually even easier way first to start with a blank project here and this is with [brownie mixes](https://github.com/brownie-mix).It has ton of boilerplate code for us to go ahead and get started to start start developing.The one we're gonna be working with is chainlink-mix piece.This gives us some wonderful contracts, tests, brownie config and really everything we need to do to get started.If you've brownie installed, you can just bake this mix.

`brownie bake chainlink-mix`

We'll get new chainlink folder with everything inside of it.In contracts we've a whole bunnch of different samples of working with the vrf, pricefeed, keepers to automate our smart contracts and making api calls and delivering any api call that we want to the blockchain.It also has a brownie config which already has a number of wonderful pieces in each networks.So that we don't have to go copy paste and add it in here.It's even got support for testnets like avalanche, polygon, binance and more.It has a number of really powerful tests including testing some pricefeeds.It has whole bunch of deployment scripts, some mocking scripts, some helpful scripts and really everything that we need to get started and get going.For starters we can run  `brownie test` and it's going to compile everything and then on a development chain run all the unit tests and if we want to test on a real testnet, we could do `brownie test --network rinkeby`

If you're looking for a good starter place that has alot of really powerful smart contracts for you to get started, I highly recommend using this mix as a boilerplate starting point for any of your contracts or any of your projects.


## Lesson 9: ERC20s, EIPs, and Token Standards

We've learned a ton of fundamentals of working with brownie and smart contracts.Now that we've kind of all the building blocks though we can actually code alot of these much faster and much more efficiently than before.

One of the things that we've seen over and over again is working with tokens and the ERC-20 token standard.We're going to learn how to build our own token.Before we do that let's understand why we'd even want to do this.

![tokens](/Images/Day11/j1.png)

ERC20s are tokens that are deployed on a chain using what's called the ERC20 token standard.You can read more about ERC-20 token standard [here](https://eips.ethereum.org/EIPS/eip-20).Well basically it's a smart contract that actually represents a token.So it's a token with a smart contract.It's both.Tether, chainlink, uni token and dai are all examples of ERC-20s.Technically chainlink is in the ERC677 as there as upgrades to the ERC20 that some tokens take that are still backwards compatible with ERC20s.So basically you can think of them as a ERC20s with a little additional functionality.

**Why make an ERC20?**

- Governance Tokens
- Secure an underlying network
- Create a synthetic asset


**How do we build one of these tokens?**

All we have to do is build a smart contract that follows the token standard.Build the smart contract that has functions like name, symbol, decimals etc as mentioned in [here](https://eips.ethereum.org/EIPS/eip-20).We need to be able to transfer it, get balance of it etc.Again if you want to check out some of the improvements that are still ERC20 compatible like the ERC677 or the ERC777, you can definitely check those out and build one of those instead.Let's create our new folder and get started.To create new brownie file:

`brownie init`

It's going to startup our repository and everything that we're going to work with here.We can kind of actually just jump in and start with our contracts.Let's create a new file inside contracts directory called "OurToken.sol" and this is where we're gonna add all of our token code.

Since [this](https://eips.ethereum.org/EIPS/eip-20) is an EIP, we could grab all the functions and past them inside our file "OurToken.sol" and then you know code all these up like these does some stuff blah blah.Or we could do it the much easier way.Since we're engineers we don't always want to reinvent the wheel.So once again our friend OpenZeppelin have some amazing [contract packages](https://docs.openzeppelin.com/contracts/4.x/erc20) for building our own ERC20 token.

![ERC20](/Images/Day11/j2.png)

This is the entirety of the code that is needed to make an ERC20.We can copy and paste this.Boom we've our ERC20 token.Let's actually change the name of everything here though.We're gonna be using solidity version 0.8 which I know I've done alot of this in 0.6 but I highly recommend working with 0.8 because it has a lot of really fantastic improvements to solidity.

**Solidity 0.8**

You'll notice this is our first dive into using a different version of solidity.You'll notice that most of the syntax is exactly the same.There are like I said couple of nice improvements with 0.8.The main one being you no longer have to use those safeMath functions that we talked about before.

Then we go ahead and import openzeppelin.Since we're importing openzeppelin, we're gonna add this to our brownie config and before we even get started, you technically have all the tools that you need to code and deploy your own ERC20 token.

Now I'm actually gonna challenge you to go ahead and try to start a brownie project, create your own token using openzeppelin packages and then deploy it on a testnet.I'm going to show you how to do all of it anyways but challenging yourself and trying to do things your own way and exploring is really one of the fastest ways to learn and grow in this space.

We need to add dependencies in our brownie-config file.

![dependencies](/Images/Day11/j3.png)

If you go to Github of [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts), you can see the latest release.4.5.0 is the latest relaease at this time.So I used it.

![openZeppelingVersion](/Images/Day11/j4.png)

Now we can import ERC20.sol contract from OpenZeppelin.Let's change the contract name to OurToken which we're going to inherit from [ERC20 from OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol).In our constructor, we're going to add our initial supply which is going to be in a wei and we're going to use the constructor of ERC20.It uses name and a symbol.We'll give a name to our token as "OurToken" and the symbol we'll do "OT".This is literally all we need for our token here.

![OurToken](/Images/Day11/j5.png)

**1_deploy_token.py**

For scripts all we have to do is create a new file "1_deploy_token.py" and "helpful_scripts.py".We'll quickly add get_account function in our helpful_scripts.You can go ahead and just copy paste from the last one.And to make sure add __init__.py inside scripts folder too.

![helpfulScripts](/Images/Day11/j6.png)

Now in our deployment token script,we'll do our imports.

![imports](/Images/Day11/j7.png)

Since we knoe that we need an initial supply in our "OurToken" contract, let's go ahead and go that.

![tokenDeployment](/Images/Day11/j8.png)

If you don't have your environment variable set, add your .env file where you can add private key, web3 infura project id and ether scan api.And then last but not least we'll add .env in our config.If you want to actually deploy this to testnet, you need to make brownie know where to grab private key from.

![privateKey](/Images/Day11/j9.png)

We can run the scripts

`brownie run scripts/1_deploy_token.py` and you will see our token is printed out.

![output](/Images/Day11/j10.png)

We can see we've our token deployed on our local ganache.I can run this again on rinkeby.

![rinkeby](/Images/Day11/j11.png)

Grab the address and go to rinkeby etherscan, pop it in and after quick refresh, You can see contract been added.You can even go to your metamask then to assets, add the address to our metamask, add the token and you'll see you'll be the owners of "OurToken".

**Don't do this now**

Something else you might wanna do is add this to a liquidity pool or add this to a place where you can actually go ahead and sell it and put it on the market.You can do something like that as easily as just popping onto uniswap, going to pool, hitting more, creating a pool and then adding our token.We'd have to manage the token list and be sure to add the token, create our own pool and automatically put it on uniswap.That's how easy it is to actually sell it on one of these pools.


##  Lesson 10: Defi & Aave

I thought we know a little bit more about Defi and why it's such an amazing technology that only works in the blockchain world.Let's look at this site [defi pulse](https://www.defipulse.com/) or if you want to look at another one called [defilamma](https://defillama.com/) which also shows alot of different protocols.So defipulse is an application that shows some of the top defi projects based on how much total asset is locked into each protocol.Aave which currently is the number one ranked defi application with 9.32 billion in assets under management in terms of USD.We've some fantastic ones like curve, compound, maker, InstaDApp etc.Now we're gonna be looking at two of these protocols in particular.The first one ofcourse being Aave and second one is gonna be what's called a decentralized exchange "paraswap".You start with aava.We're going to go to [testnet.aave.com](https://staging.aave.com/) that looks something like this with please connect your wallet and everything will be pretty empty.

**Decentralized Exchange(DEX)**

[Paraswap](https://app.paraswap.io/#/?network=ethereum) is what's known as a dex or a decentralized exchange.It allows us to trade tokens incredibly easy on the blockchain.Now there's not a whole lot of testnet indexes that actually work.So we're just going to look at them and simulate as if we're working on them.For example if I wanted to trade 1 eth for some usdt or maybe some wrapped bitcoin or some dai or some aave or really any token that we wanted, all we need to do is connect to our wallet and swap button would show up and we could go ahead and hit swap.Some of these really powerful these dexes and really popular ones are going to be curve finance, uniswap and it's really really easy way to go ahead and swap your tokens for one another depending on what you're looking to do.

Aave is incredibly powerful and it's going to be one that we're going to be working alot with because it has pretty much all the fundamentals of working with the defi protocol that we're looking for and it has a [testnet](https://v3-test.aave.com/#/dashboard) that we can go ahead and test and simulate actually working with some of these protocols.So we're gonna first work with the UI or the user interface and then we're going to do everything here programmatically.

**Get some Kovan ETH**

First things first if you don't already have it make sure you've some testnet ethereum at least.You can get some testnet ethereum from looking at the [link token contracts](https://docs.chain.link/docs/link-token-contracts/) and going to Kovan.Once we see some eth in our Kovan testnet we can go back to aave.So whereas paraswap allows you to simply swap between assets and do a lot of buying and selling of tokens, aave is a lending and borrowing application.So we can actually put down a token as collateral and we can borrow and we can generate some yeild from interacting with this protocol.Borrowing and lending is a critical piece to doing any type of really interesting financial applications or financial instruments such as short selling, being exposed to more assests etc.You can also gain some percentage back.

![apy](/Images/Day12/k1.png)

If you look at apy, it'll tell you how much percentage over a year you'll actually get in returns from staking or depsiting an asset.We're gonna connect the application using metamask and you'll see on a asset to supply, we can see our balance.

**Depositing tokens/ Lending**

What we can now do is click on ethereum, click on max button to deposit some ethereum, hit continue and a little dashboard will pop up asking us "would you like to deposit?".Clicking the deposit button will actually have us deposit right onto the aave contract on the Kovan testnet.Make sure once you hit the deposit that you're actually on a tetnet.

![depositEth](/Images/Day12/k2.png)

I did it on a rinkeby testnet.Idk why my Kovan isn't working while doing this.

![aaveDeposit](/Images/Day12/k3.png)


**WETHGateway**

Funnily enough you'll see that this is the WETHGateway.

![WETHGateway](/Images/Day12/k4.png)

When we deposit our Rinkeby Eth, it actually gets transferred into an ERC20 version of our Ethereum and then it'll go ahead and deposit in into the aave contract.

**Interest Bearing Token (aToken)**

aETH is what's called an interest-bearing token and it goes up in real time.You'll see if eth amount going up if I looked my wallet for longer period of time.This is the profit given to us from other people borrowing the ETH that we've deposited into aave.If we go to our dashboard now,

![ETHDeposited](/Images/Day12/k5.png)

We can see we've 0.393 ETH deposited and if you roll over it, you'll constantly see amount go up and up.We can go ahead and withdraw our eth which will convert our aETH back into ETH with the additional interest that we got from depositing.So depositing into aave will give us interest back as a payment for other people borrowing the ETH that we've deposited.We can also use this ETH as what's called collateral.

If I go to the borrow tab, I can actually use the ETH to borrow some other asset.Maybe I wanna borrow dai which is a stable coin meant to always equal one dollar.USDC and USDT also are meant to always reflect a dollar.We can borrow what's called wrapped bitcoin(WBTC) which represents the Bitcoin price.

**Why borrow?**

Now borrowing as asset is incredibly incredibly powerful.By borrowing you're allowed to obtain liquidity without selling your assets and borrowing is one of the first pieces in order to actually short sell.Borrowing in defi protocols is absolutely massive because it allows you to:
- Frictionlessly short sell
- Obtaining liquidity without closing your positions
- Gaining yeild on some deposited collateral
- Massive number of new things only in defi world such as flash loans

`Important Note`:
                Since we're just borrowing on testnet and this isn't real money.This is 100% okay to experiment with and work with.However if you borrow an asset and you do not pay attention to how much you've for an underlying collatera, you could get liquidated and loose some of your funds.So be very careful and pay alot of attention if you're gonna do this on an actual network.
                
Let's say we wanna borrow aave token for example.We click into aave and we choose the amount we want to borrow.Since we've placed down some collateral 0.3ETH, if the amount that we borrow ends up being too high, we'll actually get what's called liquidated.Everytime we borrow an asset, we get some type of health factor.The health factor represents how close to being liquidated you're.Once your health factor reaches 1, the collateral that you've actually deposited will get liquidated and somebody else will get paid to take some of your collateral.This is so that the aave application is always `solvent`.Being solvent means It's never in debt.

When I wanna borrow I want to choose some amount that might be a little bit safe here.So that I'm not going to get liquidated.I'm gonna choose some number where I see a health factor maybe like 5.4.

![healthFactor](/Images/Day12/k6.png)

and hit continue.Now we'll have to choose our interest rate.

![Interest](/Images/Day12/k7.png)

**Stable Vs Variable Interest Rate**

When we borrow an asset, we actually have to pay some interest.This payment is actually going to go to the people who are depositing the asset.The interest rate that we're gonna pay is actually gonna be paid to those who are depositing the asset that we're borrowing.So like how we're getting interest on our deposited collateral, others are getting interest on their deposited collateral based off of how often people are  borrowing it.We choose a stable apy which will always be 9.42% or a variable apy which will change based off of how volatile and how in demand this asset is.For now I'm going to choose variable but you can pick whatever you want.Same interface is gonna show up so hit borrow, metamask is gonna pop up and ask us if you really want to borrow.We're gonna hit confirm.

![success](/Images/Day12/k8.png)


We've successfully borrowed link into our application.We can even hit this liitle add link to your browser wallet button, to add the token to our wallet.We can now see link is indeed in our token assets.If we go back to our dashboard, you'll see we've health factor score.

![healthFactorScored](/Images/Day12/k9.png)

This is a really important score.If you click on the little i thing, it says:

![Ithing](/Images/Day12/k10.png)

We'll see all of our deposits here.We've 0.393 ETH deposited and 16 LINK deposited.You'll see whole lot of stats for working with our application.We can withdraw our ETH, borrow more LINK or we can go ahead and repay.We can either repay from our wallet balance or from our current collateral.Let's go ahead and do from our wallet balance.We'll hit max and continue.We even get this little thing that says you don't have enough funds to repay the full amount.Well why is this the case?We just borrowed the amount.It's because already since depositing, we've accrued a little bit of extra debt.Remember we hit that variable apy and every second it's going to tick up just a little bit.So let's go ahead and pay back what we can with our wallet.

Aave is one of these applications that relies on the chainlink pricefeeds in order to understand the ratio between how much you've deposited as a collateral and then how much you can borrow and take out.

Keep in mind when working with some of this.This is a testnet and we're working is just in a testnet.Sometimes the testnet doesn't work quite as well as mainnet because it's just for testing and doesn't have the exact same support.we were just working on the testnet but if you want to go to aave for real, you can go [here](https://app.aave.com/).Connect your wallet on the ethereum mainnet and interact with it exactly the way we just did.If we're on the mainnet, we can see some additional pieces.

![AaveMain](/Images/Day12/k11.png)

**Reward token / Governance token**

When you deposit something like ETH, you get 0.33% back as interest paid to you for depositing the ETH.You also get a little bit of what's called a governance token.You'll also get a little bit of aave token.I know it's really small but this is an additional incentive that aave has given the users for working with their protocol.Since aave is a decentralized protocol, in order for anything to be improved or anything to be updated on the protocol, it actually has to go through a decentralized vote.So these governance tokens actually dectate and decide how the protocol improves moving forward.

**Programmatic interactions with Aave**

Now that we understand how to work with all of that through UI, let's actually learn how to interact with aave and defi all from our scripts.

**Qunt Defi Engineer**

Learning how to do this way will get us one step closer to being `quantitative defi engineer` or `defi researcher`.This is someone who programmatically does algorithmic trades, algorithmic modelling and just does everything in a programmatic sense making them much more efficient and powerful interacting with defi.

Create a new folder "AAVE_BROWNIE_PY" and open up with VScode to the folder.Let's get into it.

Aave has some fantastic [documentation](https://docs.aave.com/developers/getting-started/readme) that we're gonna be using.

**Aave brownie setup**

Let's go ahead and start with our basic brownie set up.

`brownie init`

**No contract deployments here**

Now for working with brownie we're actually not gonna be deploying any contracts because all the contracts that we're gonna work with are already deployed on chain.All of them are just going to be working with aave.

Create a quick README.md.We can know what we're doing here.

![readMe](/Images/Day12/k12.png)

This will be the full functionality of working with Aave in this deployed contract.But we not do 2.1 for now.

Everything that we're gonna learn here will teach you how to work with other contracts as well such as paraswap or uniswap or any other type of swapping contract that will allow us to buy and sell.

**aave_borrow.py**

So let's just go ahead and create a scripts.We'll call it aave_borrow.py.Let's create a function called main and we'll just do pass for now.

**aave brownie setup**

First thing that we need to figure out how to do is deposit some eth into aave.When we actually deposited our eth via the UI, we could actually see when we call the deposit function, oddly enough if we go to the contract address in rinkeby etherscan, we'll see the address is actually what's called a `WETHGateway`.What aave is doing like I said before is swapping our ethereum for WETH.Again WETH is a ERC20 version of ethereum and this allows to easily work with all the other ERC20s on the aave protocol.

So we actually have to do that as well.

**Converting ETH -> WETH**

So the first thing we're gonna do actually isn't deposit some of our eth, but swap our Eth for WETH.So let's even put this in it's own little script.We'll call it get_weth.py.So we're gonna have a function main and we'll just do pass for now.We actually want to use this get_weth scripts in our aave_borrowed.py.So we actually have a main and we're gonna have get_weth function as well.In our main function you're just gonna call get_weth.

![Setup](/Images/Day12/k13.png)

So how do we actually convert our ethereum to WETH or wrapped ether?

Now to save gas we'd actually interact with the WETHGateway for aave but I'm going to go through how to get WETH in general.We can look up the [WETH kovan contract etherscan](https://kovan.etherscan.io/token/0xd0a1e359811322d97991e03f863a0c30c2cf029c).

![WETHEtherScan](/Images/Day12/k14.png)

We can go to contract and we can see this is indeed verified.

![VerifiedContract](/Images/Day12/k15.png)

The way WETH works is there's withdraw and deposit (on write contract section).We deposit ETH into this contract and it transfers us some WETH.So this is the first contract that we actually want to interact with.So we need our script to be able to call the deposit contract.

So per usual the two things that we need to do this is going to be an:
- ABI 
- Address

**Get the WETH interface**

I really like just doing everything directly from the interfaces.You can get WETH interface from [here](https://github.com/PatrickAlphaC/aave_brownie_py_freecode/blob/main/interfaces/IWeth.sol).Copy and paste it inside the interface directory.You can see this has all the exact same functions as our deposit contract, symbol, name, transfer, pretty much you'd expect from ERC20 plus this extra deposit piece.

So we've an interface now and we also have an address.But again above image has an address on a Kovan network.Since we know ahead of time that we're probably gonna be using this on different networks like mainnet, rinkeby etc, we'll add our brownie-config and add our networks here.

![Kovan](/Images/Day12/k16.png)

We're going to add the rest of the pieces.

![wallets](/Images/Day12/k17.png)

and That's all we really need for now.Since we've done some work with testing we know that for testing, we could do our integration test on Kovan because there's an integration test there.But what about our local tests?Well this is something good that we're thinking about right now.We know that aave actually has all these "WETH" same contracts on the mainnet as well and we also know that we're not gonna be working with any oracles because that we don't actually have to deploy any mocks ourselves.We can if we want to but we don't have to.

What we can do is for our unit tests is we can just actually use Mainnet-fork network and just fork everything that's on the mainnet into our own local network.So instead of actually using mocks, we'll basically just mock the entire mainnet and one more time just so that we absolutely have it here.`If you're not woring with oracle's, you don't need to mock responses.We can just go ahead and use a mainnet fork to run our unit tests.If you're using oracles then it makes alot more sense to do to development the network where you can mock oracles and mock oracle responses.`


With this in mind we know that we're going to be doing alot of our tests on mainnet fork.We can go ahead and add a mainnet fork in the network and then we can just add the [mainnet weth token](https://etherscan.io/token/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2) for mainnet fork.

Remember absolutely positively if you want to double check that the contract address that you're working with is correct, I highly recommend you to do so because if you get it wrong, you could accidentally add some money to a contract address that you don't want.

![mainnetFork](/Images/Day12/k18.png)

And in our termianl we can do  `brownie networks list`.

![networkLists](/Images/Day12/k19.png)

We can that indeed we've a mainnet fork here.That's going to use the ganache-cli to fork mainnet for us.

Now that we've the interface we know that we can actually compile it down to the abi.So back in our get_Weth, first thing we need to do to make any transaction obviously is get an account.This is where we can go back and make our helpful scripts.

![helpful_scripts](/Images/Day12/k20.png)


We've our account where we can make some transactions with.Let's go ahead and get our WETH contract.To do this we can import interfaces fromm brownie.

![gettingContract](/Images/Day12/k21.png)

**Why not get_contract?**

You might be asking "Why aren't we using the get_contract function?"Well you can absolutely 100% go ahead and use that get_contract function but since we're gonna be testing on mainnet fork I know that we're always going to be refer back to the config.So I'm confident that I'm not going to be deploying any mocks.It's better practice to go ahead and use that get_contract function but for this one we'll just make it a little simpler and use the config.

For going to mainnet or for to real production, you could also have a mainnet network and it'll just be an exact copy of mainnet-fork.And remember we want our .env files our environment variables to get pulled from that .env file.

![config](/Images/Day12/k22.png)

Now everything in our .env file will pulled in automatically.Great we've an address and abi which comes from the interface.Now we can just call deposit function where we deposit ethereum and we get WETH.

![getWETH](/Images/Day12/k23.png)

Let's go ahead and run this script then.

`brownie run scripts/get_weth.py --network kovan`

![OutputWETH](/Images/Day12/k24.png)

We can use our transaction hash, pop into Kovan etherscan, you could see transaction going through.In our wallet we'll get -0.1 eth and we'll get +0.1 weth.To add this and see in our metamask, grab the contract address and add a token.

If you wanna switch back your WETH to ETH, you can just hit the withdraw function or you can programmatically add withdraw function.

![withdraw](/Images/Day12/k25.png)

Now we've ERC20 token "WETH" that we can use to interact with the aave appliction.Now that we've get_weth function let's go ahead and start borrowing.

**aave_borrow.py**

Let's go ahead and start with our account.

![get_Acc](/Images/Day12/k26.png)

We're gonna get WETH address or we can even just do our ERC20 address because the WETH token is in ERC20 and maybe we wanna deposit some other ERC20.

![ercAddress](/Images/Day12/k27.png)

And now we wanna call this get_weth function just in case we don't already have.We'll import get_weth from scripts but we don't actually need to call it right now because we already have some wrapped ethereum in our Kovan address.If you wanna test this though on our local mainnet-fork we probably will want to call this get_weth.So I'm just gonna add a little if statement.

When we call get_account in our scripts, it actually knows that it's a local environment that we're working with and it'll just return accounts[0].Instead of us having to actually load a private key in every single time and we want to actually wait for our transaction to complete in our get_weth function.

![getWeth](/Images/Day12/k28.png)

We can run `brownie run scripts/aave_borrow.py --network mainnet-fork`

![running_getWETH](/Images/Day12/k29.png)

Testing everything on mainnet-fork is going to give us a really accurate view of what doin this on mainnet actually is going to give us.We don't need to do any mocking.We can literally just fork all of mainnet and go from there.We're still gonna test on Kovan though in a little bit just so we can see all the transactions that go through, how long it takes for stuff to happen etc.

So now that we've got some weth, we actually need to go into our second bit.We're going to deposit some ETH in Aave.In our case some WETH.So how do we actually do that?

Well everything that we need is going to be in [Aave documentation](https://docs.aave.com/developers/getting-started/readme).

**Lending Pool**

Where we deposit and borrow from in Aave is in their contract LendingPool.It have all of the functions that we need.It has deposit where we deposit our asset as a collteral, withdraw where we take it back, borrow, repay and a couple other interesting ones which we'll go into later.But for now we just really need to focus on repaying, borrowing, withdrawing and depositing.So as you probably guessed deposit is the function that we're gonna work on right now.Since this is the contract that we're gonna work with, as always two things you need when working with a contract are gonna be the `ABI` and the address.So we're gonna get this lending pool contract.

**LendingPool Address Provider**

Something about this lending pool is that the lending pool address can actually change little bit depending on alot of different pieces.There's this address provider which gives us the address of a specific or particular market.If we go back to the [Aave UI](https://classic.aave.com/#/markets), there's actually different markets.

![Markets](/Images/Day12/k30.png)

There's different types of ways we can interact with aave.We're just gonna work with the basic Aave V2 because it's easily the most used on mainnet.As well as the address provider registry will give us so this address provider will give us the address of the lending pool for our market.If we want to go across different markets, we have to go to [address provider registry](https://docs.aave.com/developers/core-contracts/pooladdressesproviderregistry) to find it but the addresses in here don't change.There's just one function that we need to work with this is getLendingPool which will give us the address of the actual lending pool.

So don't let it confuse you too much.Basically all we're trying to do is we're saying where's aave located right now and aave has a contract that will always tell us where the main aave contracts are and that's this addresses provider.So This is another contract that we've to work with.

Again when we've a contract, we need ABI and address.So we can absolutely once again we could go ahead and use interface because life is great with an interface.If we know we're only gonna work with one or two functions, we can actually just make the interfaces ourself.So an interface, we could do new file and give it a name "ILendingPoolAddressProvider.sol" and we can just add it in here ourselves.

Tips: You don't need the whole interface.Just define the functions that you'll work with. 

![Interface](/Images/Day12/k31.png)

We know that there's only one function called getLendingPool and we're not exactly sure what getLendingPool is defined as but what we can do is we can go to [aave's github](https://github.com/aave/protocol-v2/blob/master/contracts/interfaces/ILendingPoolAddressesProvider.sol) where we can see:

![getLP](/Images/Day12/k32.png)

It's an external view and returns address.Let's make our getLendingPool the same.

![getLendingPool](/Images/Day12/k33.png)

We could run with this and this would work perfectly fine but this leads us to the next point we might just as well grab the whole thing.This way we know for fact we're not getting anything wrong.If we wanted to, our interface could be this only because this is going to compile down to an abi and the abi is gonna say "There's a function here."and that's all the abi is really doing.It's just telling us how we can interact with a contract but let's go ahead and everything so that if we want to interact with more things, we can.

So now we've the abi, we also now need an address which we can definitely find from the [aave documentation](https://docs.aave.com/developers/v/2.0/deployed-contracts/deployed-contracts).We're gonna find LendingPoolAddressProvider, copy that and put it in our brownie-config.

![lendingPoolAddress](/Images/Day12/k34.png)

Now that we've an abi and the address for both Kovan and mainnet-fork, what we can do now is first get the lending pool addresses provider from the interface.

![gettingLP](/Images/Day12/k35.png)

Then we want to return the address of the lendingPool.

![gettingLPaddress](/Images/Day12/k36.png)

Because the address provider has this getLendingPool which returns the address of the lending pool.Now that we've the address, we can actually return the lending pool contract by once again getting the abi and the address of the actual lending pool.So we have the address, we just need the abi which once again we can work with our wonderful interfaces "ILendingPool.sol".

There's only gonna be couple of functions we're going to work with but aave actually gives us the [interface](https://docs.aave.com/developers/v/2.0/the-core-protocol/lendingpool/ilendingpool).

**Fixing Importing Dependencies**

We do need to actually change one thing in ILendingPool.sol.This interface imports locally with `./`.So we actually just need to change these imports to actually import directly from github instead of importing locally.Luckily this is something we already know how to do.So let's go to our brownie-config.

![dependencies](/Images/Day12/k37.png)

This way brownie will download this right from github and now we can just use @aave instead.So back in our ILendingPool.sol, we can change `./` to 

![importingDep](/Images/Day12/k38.png)

Now we've actually imported this interface for us to use,we can go ahead and just compile just to make sure that everything is working correctly.

`brownie compile`

If these interfaces had an issue, they actually wouldn't compile through brownie.

Now that we've the interface, we know that these interfaces compile down to the abi and we already have the address.So to actually interact with the lending pool now.

![ReturningLP](/Images/Day12/k39.png)

Now we've a function that goes through the lending pool addresses provider from the aave documentation and returns the lending pool contract that we can now interact with.

Now that we've the actual address, what we're going to do now is we're gonna take this WETH that we've got this ERC20 version of Eth and we're going to deposit it into this contract just like what we did in the UI.In order to actually first deposit it, we need to approve this ERC20 token.

ERC20 tokens have an approve function that makes sure that whenever we send a token to somebody or whenever a token calls, a function that uses our tokens, we actually have given them permission to do so.So that's the first thing that we actually have to do is we're gonna have to approve sending our ERC20 tokens and this resembles so.Since I know we're going to have to approve alot, I'm actually just going to go ahead and make an approve ERC20 token function similar to what we did with the getLendingPool.

![approveERC](/Images/Day12/k40.png)

How do we actually call this approve function on a token contract?Well as always we're gonna need the abi and the address of the token contract.Now we could create our interface ourselves, looking at the functionalities of the ERC20 tokens or grab it from [here](https://github.com/PatrickAlphaC/aave_brownie_py_freecode/blob/main/interfaces/IERC20.sol).Copy everything and paste it inside IERC20.sol inside interfaces.So you can see number of different functions.We can check the allowance, balanceOf different addresses, how many decimals a token has, the name, the symbol, do some transfer and then the function that we're gonna be using is approve function.We can see the parameters the approve function takes.We're gonna need to have a spender and how much they can actually spend.So 

if we come back to approve_erc20, we know for input parameters are amount, spender address, erc20 token address and account.

![approve](/Images/Day12/k41.png)

So back up in our main function, we could call approve_erc20 for some amount, the spender is gonna be the lending_pool address, erc20_address and account.The only thing that we haven't defined right now is some amount which we can make it really whatever we wanna be.To keep things standard let's make it 0.1. 

![approveFunction](/Images/Day12/k42.png)

Now we can run `brownie run scripts/aave_borrow.py --network mainnet-fork`

We can see that our approve function is working as intended.It's annoying to do --network mainnet-fork so we'll change our default to mainnet-fork.

![default](/Images/Day12/k43.png)

Now we just need to deposit it into aave.Since we know we're probably gonna use this alot too, let's go ahead and create a deposit function.

**deposit function**

Since we've everything approved we can now go ahead and use the lending pool deposit method and we can check the [documentation](https://docs.aave.com/developers/v/2.0/the-core-protocol/lendingpool) to see what the parameters that it takes are.

![depositParameters](/Images/Day12/k44.png)

First thing is gonna be the address of the asset which we know is gonna be erc20_address, amount of the token, address onBehalfOf is just gonna be our account.address.We're depositing the collateral for ourselves and then referral code which is actually deprecated and workloads don't actually work anymore so we're always gonna be passing 0.

![deposit](/Images/Day12/k45.png)

Now we can run it to see if everything's working fine or not.

`brownie run scripts/aave_borrow.py`

If you get the `"SafeMath Substraction Overflow error"` then change the datatype of amount in ILendingPool.sol to int256 run the script.It'll run fine and again keep the datatype as it was before i.e uint256.

Now that we've some collateral deposited, we can go ahead and actually take out a borrow.We can go ahead and borrow some other asset.The question gonna be how much.How much can we actually borrow?How much should be borrow?What would result in positive health factor?

**getUserAccountData**

Maybe we should actually pull off chain some of our stats.How much do we actually have deposited?How much collateral we've?How much debt we've and so on and so forth.That way in the future when we don't start clean, we can take some inventory of where we stand with our collateral in our debts.

At the [aave documentation](https://docs.aave.com/developers/core-contracts/pool), we can go ahead and see the getUserAccountData function.This is going to return the user account data across all reserves.So it's gonna get the totalCollateralETH that we've deposited in terms of ethereum, total debt in terms of ETH, how much we can borrow: the borrowing power we have, liquidation threshold or how close to that liquidation threshold will be, loan to value ratio and again health factor.This health factor is obviously incredibly important because if it drops below 1 or reaches 1, users can call liquidation call.This function all these variables but for now we really only care about how much collateral we've, how much debt we've and how much we're available to borrow.So let's go ahead and write a function that will actually sort that for us.

![accPara](/Images/Day12/k46.png)

We're looking to call get_borrowable_data function on the lending pool from an account.So let's go ahead and call that function.

![lendingPool](/Images/Day12/k47.png)

If we look at the API, all that it needs is a user's address to get started and it return 6 variables.

![returningValues](/Images/Day12/k48.png)

getUserAccountData is a view function so we don't need to spend any gas.All of the variables are gonna be returned in terms of wei.So let's just go ahead and convert these from wei to something that makes a little bit more sense to us.

 ![get_borrowable_data](/Images/Day12/k49.png)
 
 The reason that we'd to add float variable is that without it some of the math that we're gonna try to later won't pan out.
 
 Now we've this function get_borrowable_data and we're gonna pass lending_pool and account.Since we're returning available_borrow_eth and the total_debt_eth, we do:
 
![gettingBorrowableData](/Images/Day12/k50.png)


Let's go ahead and try this out.

`brownie run scripts/aave_borrow.py`

We've deposited 0.1 worth of ETH, 0 ETH borrowed and we can borrow 0.08 worth of ETH.The maximum amount that you can borrow will always be less than your collateral.This is because of the `liquidation threshold`.

**liquidation threshold**

In the [risk parameters documentation](https://docs.aave.com/risk/asset-risk/risk-parameters), we can see different liquidation thresholds on different assets.We can see Ethereum has 80% loan to value(ltv).With Ethereum we can only borrow upto 80% of the deposit assets that we've.And If we have more than 82.5% borrowed, will actually get liquidated.It also tells about the liquidation bonus, reserve factor and some other helpful pieces.

**Borrowing DAI**

Now that we've this borrowble ETH amount, we can go ahead and actually borrow some DAI.

**Getting DAI conversion rate**

In order for us to borrow some DAI, we also need to get the conversion rate.We need to get DAI in terms of ETH.We're going to have to use some price feed here.Luckily we already know how to work with chainlink and how to get pricefeeds.Aave uses the chainlink pricefeeds as well.So we're using the exact same conversion rate tools that aave's gonna use.Let's create a function to get us the conversion rate.

![dai_rate](/Images/Day12/k51.png)

we passed the dai_eth_price_feed which will be the address of the dai ethereum conversion rate.Let's go ahead and create get_asset_price function.

First thing we're gonna need is this die_eth_price_feed address.Where can we get this?As we know per usual we'll head over to [chainlink documentation](https://docs.chain.link/docs/ethereum-addresses/), grab the address and paste it into our config for mainnet-fork and for Kovan as well.

![dai_ETH](/Images/Day12/k52.png)

and then we can get the address of the same way we got the address of the WETH token.

![gettingAddress](/Images/Day12/k53.png)

Now we've a way to change the price feed address depending on what network we're on.So in our get_asset_price function, we're gonna do the same exact thing that we always do.We're gonna grab an ABI and an address to work with the contract.Again we can get the ABI by just working directly with the [interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol).

![passing_address_inV3](/Images/Day12/k54.png)

Now the dai_eth_price_feed is gonna be a contract that we can call a function on.We can always refer back to [get the latest price documentation](https://docs.chain.link/docs/get-the-latest-price/) to see how to actually wort with it.Even simple python code is there for working with it in Web3.We're gonna go ahead and call latestRoundData function which we can also find in our AggregatorV3Interface which returns roundId, answer, startedAt, updatedAt and answeredInRound.All we're really concerned with is answer.The way we can do this is :

![gettingDaiETHPrice](/Images/Day12/k55.png)

So let's go ahead and run this:

`borwnie run scripts/aave_borrow.py`

We know that DAI/ETH price feed has 18 decimal place.The number that shown of the screen isn't the real price.The real price is divisible by 10**18.But this number is difficult to read.So what we can do is we can use the method of fromWei from Web3.

![ConvertedToEther](/Images/Day12/k56.png)

Now we've DAI/ETH price.We're getting really close to borrow this actual asset.Let's even return the converted_latest_price just so that we're always working in units that we understand.

Now we can calculate the amount of DAI that we want to borrow.

![AmountDai](/Images/Day12/k57.png)

And just to be safe we times it by 0.95 to make sure our health_factor is better.This line we're converting our borrowable eth to borrowable dai and then we're timsing it by 95%.We're timing it by 95% because we don't wanna get liquidated.Remember how we slid that sliding scale around to make it safer and less safe.Well the lower percentage that we actually borrow maybe we even borrow 50% of our collateral the safer that we're gonna be.Keep that in mind when you're deciding how much to actually borrow if you wanna run this in a production environment.

Finally we'll borrow now.Looking at the [aave documentation](https://docs.aave.com/developers/core-contracts/pool), we can look at their borrow function.Let's go ahead and call this function.

**Getting DAI address**

First we should get a DAI address which once again we'll want to put it in our config.We'll add the dai_token which we can find from [etherscan dai token](https://etherscan.io/token/0x6b175474e89094c44da98b954eedeac495271d0f?a=0x2faf487a4414fe77e2327f0bf4ae2a264a776ad2#writeContract).

![mainnetDAI](/Images/Day12/k58.png)

If you want to run this on Kovan you're also gonna need to have a DAI token for Kovan.

**Aave Testnet Token Addresses**

On testnets aave actually changes up where the tokens for it's testnets are actually going to be.So if we go to their documentation, we go to deployed contracts and we go to Kovan.

![KovanFlag](/Images/Day12/k59.png)

It's gonna be the same thing for tokens.And you can get the address of DAI from [here](https://docs.aave.com/developers/deployed-contracts/v3-testnet-addresses).

![configDAI](/Images/Day12/k60.png)

![dai_address](/Images/Day12/k61.png)


Now let's move on to the next parameter.The amount which we just figured in the code above but we do need to change it back to Wei.Then our interest rate mode which is gonna be either stable or variable.Stable is where the interest rate will always be exactly the same.Variable will change depending on alot of different things going on with aave.For safety we're just gonna go with stable.Then we're gonna do referral code and onBehalf.Referral code no longer exists so we'll pass 0 and it's gonna be on behalf of ourselves.

![borrowingDAI](/Images/Day12/k62.png)

If we've done this right we should have borrowed some DAI programmatically from the Aave protocol.And we can once again call our get_borrowable_data function since this function will print out our new account information for how much we've borrowed.

Let's go ahead and run this in our mainnet-fork again.If we've done this correctly we now see that we've borrowed some DAI.


**Repaying**

We've learned how to borrow everything which is fantastic.Let's go ahead and actually repay that back.So we're gonna call their repay function and we'll put it into their own function called repay_all and we'll give the amount that we want to repay, lending_pool address and our account.

So if we're gonna pay back first thing we need to do is actually call the approve function to prove that we're going to pay back.So we need to approve that erc20.

![Approve](/Images/Day12/k63.png)

Our ERC20 already calls wait so we don't have to call it.So once we approve we're gonna be using the DAI that we've borrowed to pay most of what we've borrowed back.Now we're going to call repay function.

![repayTxn](/Images/Day12/k64.png)

First we passed the asset that we're gonna use to repay, amount, the rate mode which we hard coded to 1 and the address on behalf of.

![repayAll](/Images/Day12/k65.png)

Let's see if this works:

`brownie run scripts/aave_borrow.py`

**Kovan Run**

If you want to what we can also do is we can see if this will work with our wallet address.What I can do is copy the address of the metamask, go to Kovan etherscan and test everything you'll run through the script.

You've essentially learned everything that we need to do through to become quantitative defi wizards and build really robust financial applications in the defi world.

**Testing**

Something I wanna point out.Even though this isn't a python course and we're learning more about solidity and smart contracts, it's still in your best interest to test these functions.Yes I know they're python functions but it's still gonna be in your best interest to test them to make sure your application always works as you expect it to.This is actually gonna be even easier than that lottery contract that we did since we're just testing python functions and we can test with `brownie tests`.  

![test1](/Images/Day12/k66.png)

![test2](/Images/Day12/k67.png)














































































 
 








 










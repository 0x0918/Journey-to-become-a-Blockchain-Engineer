# Journey-to-become-a-Blockchain-Engineer

I'm sharing everything I'm learning to become a Blockchain Engineer

![Blockchain](/Images/main.jpg)

| <p align="center"> [Day 1](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day1/Day1.md) </p> |
| ------ |
|  **Blockchain** |
| - Bitcoin |
| - Ethereum |
| - Smart Contracts |
| - Bitcoin Vs Ethereum |
| - Oracle Problem & Solution |
| - Hybrid Smart Contracts |
| - Chainlink |
| - Importance of Ethereum |
| - Chainlink features |
| - Summary |
| **Features of blockchain and smart contracts**|
| - Decentralized |
| - Transparency & Flexibility |
| - Speed & Efficiency |
| - Security & Immutability |
| -  Removal of Counterparty risks |
| - Trust Minimized  Agreements |
| - Summary |
|  **DAOs**|
| <p align="center"> [Day 2](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day2/Day2.md) </p> |
| **Ethereum Transaction On a Live  Blockchain** |
| - Wallet Creation |
| - Etherscan |
| - Multiple Accounts |
| - Mnemonic ,  Public & Private keys |
| - Mnemonic vs Private vs Public keys |
| - Mainnet & Testnets |
| - Initiating our first Transaction |
| - Transaction details |
| - Gas fees, Transaction fees, Gas limit, Gas price |
| - Gas vs Gas price vs Gas Limit vs Transaction fee |
| - Gas estimator |
| **How Blockchain works/whats going on Inside the Blockchain** |
| - Hash or Hashing or SHA256 |
| - Block |
| - Blockchain |
| - Decentralized/Distributed Blockchain |
| - Tokens/Transaction History |
| - Summary |
|        |
| <p align="center"> [Day 3](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day3/Day3.md) </p> |
| **Signing and Verifying a Transaction** |
| - Public & Private Keys |
| - Signatures |
| - Transactions |
| - Summary |
| **Concepts are same** |
| - Nodes |
| - Centralized entity vs  Decentralized Blockchain |
| - Transactions are Listed |
| - Consensus |
| - proof of work/Sybil resistance mechanism |
| - Blocktime |
| - Chain selection rule |
| - Nakamoto consensus |
| - Block Confirmations |
| - Block rewards & transaction fees |
| - Sybil attack |
| - 51% attack |
| - Drawbacks of pow |
| - proof of stake/sybil resistance mechanism |
| - Validators |
| - pros & cons of pos |
| - Scalability problem & Sharding solution |
| - Layer 1 & Layer 2 |
| - Rollups |
| - Summary |
| <p align="center"> [Day 4](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day4/Day4.md) </p> |
| **Solidity** |
| **Lesson 1 - Remix IDE & its features** |
| - Solidity version |
| - Defining a  Contract |
| - Variable types & Declaration |
| - Solidity Documentation |
| - Initializing |
| - Functions or methods |
| - Deploying a Contract |
| - Public , Internal , private , External Visibility |
| - Modifying a Variable |
| - Scope |
| - View functions |
| - Pure function |
| - Structs |
| - Intro to storage |
| - Arrays |
| - Dynamic array |
| - Fixed array |
| - Adding to an array |
| - Compiler Errors |
| - Memory Keyword |
| - Storage keyword |
| - Mappings Datastructure |
| - SPDX license |
| - Deploying to a live network |
| - Interacting with deployed contracts |
| - EVM |
| - Summary |
| <p align="center"> [Day 5](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day5/Day5.md) </p> |
| **Lesson 2 - StorageFactory** |
| - Factory pattern |
| - New contract StorageFactory |
| - Import 1 contract into another |
| - Deploy a Contract from a Contract |
| - Track simple storage contracts |
| - Interacting with Contract deployed Contract |
| - Calling Store & Retrieve Functions from SF |
| - Address & ABI |
| - Compiling & storing in SS through SF |
| - Adding Retrieve Function |
| - Compiling |
| - Making the Code lil bit Simpler |
| - Additional Note |
| - Inheritance |
| - Recap |
| <p align="center"> [Day 6](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day6/Day6.md) </p> |
| **Lesson 3 - Fund me** |
| - purpose of this contract |
| - Payable function , wei , gwei & ether |
| - Mapping , msg. sender , msg.value |
| - Funding |
| - ETH -> USD /conversion |
| - Deterministic problem & Oracle solution |
| - Centralized Oracles |
| - Decentralized Oracle Networks |
| - Chainlink Datafeeds |
| - Chainlink Code documentation on ETH/USD |
| - Importing Datafeed code from Chainlink NPM package |
| - Interfaces |
| - ABI/Application Binary Interface |
| - Interacting with an Interface Contract |
| - Finding the Pricefeed Address |
| - Deploying |
| - Getprice function |
| - Tuples |
| - Typecasting |
| - deploying |
| - Clearing unused Tuple Variables & Deploying |
| - Making the contract look Clean |
| - Wei/Gwei Standard (Matching Units) |
| - getting the price using Get conversion rate |
| - deploying |
| <p align="center"> [Day 7](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day7/Day7.md) </p> |
| - Safemath & Integer Overflow |
| - Libraries |
| - Setting Threshold |
| - Require statement |
| - Revert |
| - Deplying & Transaction |
| - Withdraw Function |
| - Transfer , Balance , This |
| - Deploying |
| - Owner , Constructor Function |
| - Deploying |
| - Modifiers |
| - Deploying |
| - Resetting the Funders Balances to Zero |
| - For loop |
| - Summary |
| - Deploying & Transaction |
| - Forcing a Trasacttion |
| <p align="center"> [Day 8](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day8/Day8.md) </p> |
| **Lesson 4 - Web3. py SimpleStorage** |
| - Limitations of Remix |
| - VScode , Python , Solidity Setup |
| - VScode features |
| - Testing python install & Troubleshooting |
| - Creating a new folder |
| - SimpleStorage. sol |
| - Remember to save |
| - VScode Solidity Settings |
| - Python Formatter & settings |
| - Author's recommended Settings |
| - working with python |
| - Reading our solidity file in python |
| - Running in Python |
| - Keyboard Shortcuts |
| - Py-Solc-x |
| - Importing solcx |
| - Compiled_sol |
| - Bracket pair colorized |
| - pysolcx documentation |
| - Printing Compiled_sol |
| - Comparison wih remix (Lowlevelstuffs , ABI) |
| - Saving Compiled Code/writing |
| - import Json |
| - Json formatting/settings |
| - Deploying in Python (Bytecode , ABI) |
| - Which Blockchain/Where to deploy |
| - Ganache Chain |
| - Ganache UI |
| - Introduction to Web3. py |
| - pip install web3 |
| - import web3 |
| - Http/Rpc provider |
| - Connecting to Ganache(RPC server,Documentation,Chain ID,address,Privatekey) |
| - Deploy to Ganache |
| - Building a Transaction |
| - Nonce |
| - Getting Nonce |
| - Create a Transaction |
| - Transaction Parameters |
| - Signing Our Transaction(signed_txn) |
| - Never Hardcode your Private keys |
| - Environment Variables |
| - Setting Environment variables |
| - Limitations of Exporting  Environment Variables |
| - Private key PSA |
| - Accessing Environment Variables |
| - .env file, .gitignore, pip install python-dotenv |
| - load_dotenv() |
| - Sending the signed Transaction |
| - Deployment |
| <p align="center"> [Day 9](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day9/Day9.md) </p> |
| - Block confirmation(wait_for_transaction_reciept) |
| - interact/work with thee contract |
| - Address & ABI |
| - Retrieve() , Call & Transact |
| - Store function |
| - Creating Transaction(Store_transaction) |
| - Signing Transaction(signed_store_txn) |
| - Sending Transaction(send_store_tx,tx_receipt) |
| - Deployment |
| - some nice syntax & deployment |
| - ganache-cli  |
| - install Nodejs |
| - install yarn |
| - Run ganache cli , ganache documentation |
| - update privatekeys,addresses,http provider |
| - open new terminal & deploy |
| - deploy to testnet/mainnet |
| - Infura, Alchemy |
| - Create project |
| - update the rinkeby url, Chain id ,  address &  private key |
| - Deploying |
| - summary/recap |
| <p align="center"> [Day 10](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day10/Day10.md) </p> |
| **Lesson 5 - Brownie Simple Storage** |
| - Brownie Intro & Features |
| - install Brownie |
| - 1st brownie simplestorage project |
| - Brownie Folders |
| - brownie compile & store |
| - brownie deploy |
| - brownie runscripts/deploy. py & default brownie network |
| - brownie Advantages over web3. py in deploying |
| - getting address & private key using Accounts package |
| - add default ganache account using index |
| - add accounts using Commandline |
| - add accounts using env variables |
| - adding wallets in yaml file and updating in account |
| - importing contract simplestorage |
| - importing & deploying in brownie vs web3. py |
| - recreating web3 .py script in brownie |
| - tests |
| - Deploying to a Testnet |
| - Brownie console |
| <p align="center"> [Day 11](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day11/Day11.md) </p> |
| **Lesson 6 -Brownie Fund Me** |
| - Initial Setup |
| - Dependencies |
| - Remappings |
| - Rinkeby Deploy Script |
| - init.py |
| - Deploying to Rinkeby |
| - Deploying to ganache |
| - Mock |
| - Constructor Parameters |
| <p align="center"> [Day 12](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day12/Day12.md) </p> |
| - Refactoring |
| - Deploying to a persistant ganache |
| - Adding network to brownie |
| - Withdraw and Fund |
| - Testing |
| - Default Network |
| - Mainnet fork |
| - Custom mainnet-fork |
| - Adding to Github |
| - Where should I run my tests? |
| <p align="center"> [Day 13](https://github.com/spo0ds/Journey-to-become-a-Blockchain-Engineer/blob/main/Day13/Day13.md) </p> |
| **Lesson 7: SmartContract Lottery** |
| - Decentralized Lottery |
| - Setup |
| - Wait..is this really decentralized? |
| - Could we make it decentralized? |
| - Chainlink Keepers |
| - Lottery.sol |
| - Main functions of Lottery.sol |
| - address payable[] |
| - require minimum payment |
| - getEntranceFee |
| - Testing |
| - Enum |
| - startLottery |
| - Randomness |
| - pseudorandom numbers |
| - True Randomness with Chainlink VRF |
| - Oracle Gas and Transaction Gas |
| - Request and Receive |
| - Kovan |
| - Gas Estimation Failed |
| - After Link transaction completes |
| - After transaction completes |
| - Request and Receive |
| - Asynchronous 2 Transactions |
| - Clarification |
| <p align="center"> Day 14 </p> |
| - endLottery |
| - returns(type variableName) |
| - fulfillRandomness |
| - override |
| - Modulo(Mod Operation %) |
| - Lottery Testing |
| - deploy_lottery.py |
| - get_account refactored |
| - contract_to_mock |
| - Contract.from_abi |
| - Adding vrfCoordinatorMock |
| - Start Lottery |
| - enter_lottery |
| - end_lottery |
| - Funding with LINK |
| - brownie interfaces |
| - waiting for callback |
| - Integration Tests Vs Unit Tests |
| - Unit Testing |
| - pytest.skip |
| - test_cant_enter_unless_started |
| - test_can_start_and_enter_lottery |
| - test_can_end_lottery |
| - test_can_pick_winner_correctly |
| - Events and Logs |
| - callBackWithRandomness |
| - Integration Test |
| - Test deployment |
| - Topics |
| - Conftest.py |
| <p align="center"> Day 15 </p> |
| **Lesson 8: Chainlink Mix** |
| **Lesson 9: ERC20s, EIPs, and Token Standards** |
| - Why make an ERC20? |
| - How do we build one of these tokens? |
| - Solidity 0.8 |
| - 1_deploy_token.py |
| <p align="center"> Day 16 </p> |
| **Lesson 10: Defi & Aave** |
| - Decentralized Exchange(DEX) |
| - Depositing tokens/ Lending |
| - WETHGateway |
| - Interest Bearing Token (aToken) |
| - Why borrow? |
| - Stable Vs Variable Interest Rate |
| - Reward token / Governance token |
| - Programmatic interactions with Aave |
| - Qunt Defi Engineer |
| - No contract deployments here |
| - aave_borrow.py |
| - Converting ETH -> WETH |
| - Get the WETH interface |
| - Why not get_contract? |
| <p align="center"> Day 17 </p> |
| - aave_borrow.py |
| - Lending Pool |
| - LendingPool Address Provider |
| - Fixing Importing Dependencies |
| - deposit function |
| - getUserAccountData |
| - liquidation threshold |
| - Getting DAI conversion rate |
| - Aave Testnet Token Addresses |
| - Repaying |
| - Testing |

**endLottery**

Before even get a random number let's change the state of our lottery.

![stateEndLottery](/Images/Day9/i32.png)

While this is happening no other functions can be called.This will lock out.Nobody could start a lottery and nobody can enter a lottery while we're calculating the winner.Now that we know a little bit more about random numbers and everything that we're doing here.Let's go head and try implementing this.In our chainlink smartcontract docs, in our get a [Random number section](https://docs.chain.link/docs/get-a-random-number/v1/).First thing we're gonna do is import the VRFConsumerBase code and we'll inherit it into our Lottery contract.

![vrfInherit](/Images/Day9/i33.png)

If we scroll down to the constructor of VRFConsumerBase, we can see it address of the vrfCoordinator and the address of the chainlink token as parameters.We can use a constructor of a contract inherited in our contract inside our constructor.So what we'll want to do is we want to come down to our constructor and right after the public keyword we can add any aditional constructors from inherited smart contracts.

Similar to priceFeedAddress vrfCoordinator and link addresses are gonna change based on the blockchain that we're on.So it'll probably makes sense for us to parameterize them the same way we parameterize the pricefeed address.So in our top level constructor parameters we'll add an address for the vrfCoordinator and pass that to the constructor of the vrfConsumerBase.We'll also grab ab address for the link token and pass it to the vrfConsumerBase constructor as well.

![parameterizedConstructor](/Images/Day9/i34.png)

Great what else we need to make this work?Well back in the [documentation](https://docs.chain.link/docs/get-a-random-number/v1/) we can see:

![FeeKeyHash](/Images/Day9/i35.png)

We need fee and the keyHash.The fee is associated with the link token needed to pay for this request.So we'll make a public variable for fee.

![fee](/Images/Day9/i36.png)

Since fee might change blockchain to blockchain we'll have fee as an input parameter as well.

![feeConst](/Images/Day9/i37.png)

We need a keyHash.The key hash is a way to uniquely identify the chainlink vrf node.

![keyHash](/Images/Day9/i38.png)

Now that we've the main pieces that we need.How do we then request this random number? Well if we scroll down to ou documentation we can see we have this requestRandomness function that we need to call.If we scroll back to our vrfConsumerBase contract, this requestRandomness function is a built-in function from the vrfConsumerBase.So our contract can natively call this requestRandomness function right in our contract.You can see it takes keyHash and a fee as it's parameters.So right in our endLottery function we can add this requestRandomness function and we can also see requestRandomness returns requestId of bytes32.

**returns(type variableName)**

This return syntax is very powerful.You can actually identify the name of the variable you want to return right in your function declaration.So by saying bytes32 requestId we're saying we're going to return a bytes32 variable named requestId.

![reuestRandomness](/Images/Day9/i39.png)

This function call follows again what we've talked about as the request and receive mentality.This means that in this first transaction we're going to request the data from the chainlink oracle.In a second callback transaction the chainlink node is going to return the data to this contract into another function called fulfillRandomness.

**fulfillRandomness**

Again if we look back in our vrfConsumerBase, we can see it has this function rawFulfillRandomness.We can read in comments that says "rawFulfillRandomness calls fulfillRandomness after validating the origin of the call".There's a little bit of contract tag going on but it's gonna eventually call fulfillRandomness function which is gonna be what we define in here and that's how our contract gonna know what to do once it gets the random number back.

So in our first transaction we're gonna end the lottery, request a random number and then a second transaction later on once the chainlink node has created a provably random number it's gonna call a second transaction itself based off of what we  define.We just have to call it.

![fulfillRandomness](/Images/Day9/i40.png)

We don't want anyone else to be able to call this function.We only want our chainlink node to call this function so we can return a truly random number.So we made it an internal function.It's internal because actually the chainlink node is calling the vrfCoordinator and then the vrfCoordinator is calling our fulfillRandomness.So we made it internal so that only the vrfCoordinator can be the one to call and return this function.

**override**

This override keyword means that we're overriding the original declaration of the fulfill randomness function.Our vrfConsumerBase has a function fulfillRandomness defined but it doesn't have any parameters or anything about this function actually laid out.This function is meant to be overriden by us and that's exactly what we're doing here.

So in this fulfillRandomness function let's define what's gonna happen once we get random number back.Before we can process this random number let's just check to make sure we're even in the right state.So we'll do:

![lotteryState](/Images/Day9/i41.png)


Then just do another check to make sure we actually get a response.

![randomnessRequire](Images/Day9/i42.png)

Now we need to pick a random winner specifically our of our list of players.List of payable public players.So our players array is just a list of players.

**Modulo(Mod Operation %)**

What we can do to pick a random winner?We can do a modulo function.We can use mod function in our fulfillRandomness with the length of our players.

![indexWinner](/Images/Day9/i43.png)

And just to keep track let's make a new variable called recent winner.

![recentWinner](/Images/Day9/i44.png)

Now that we got a winner wallet we want to pay them all of the money gathered from our enters.We'll do is transafer the entire balance of the address.

![transfer](/Images/Day9/i45.png)

We'll transfer them everything we've.Then of course we're gonna want to reset the lottery so that we can start from scratch.We can start blank again.So we'll do:

![reset](/Images/Day9/i46.png)

We're gonna change our lottery state to being closed because the lottery is now complete.And I often also like to keep track of the most recent random number.So at the top we'll declare public randomness.

![randomness](/Images/Day9/i47.png)


**Some of the changes I need to fix to compile properly is here:**

I need to have v0.6 instead of 0.8 in my code while importing VRFConsumerBase.sol.

`import "@chainlink/contracts/src/v0.6/VRFConsumerBase.sol";`

also need to make recentWinner variable payable.

`address payable public recentWinner;`

and LOTTERY_STATE state to be CALCULATING_WINNER instead of CALCULATING_WINNERS.



Let's now move into our testing and developing phase.As you're starting to figure out we can ignore these file import callback not supported bugs in vscode for now.I'm sure solidity linter will get better as time progresses.

**Lottery Testing**

Let's go ahead into our scripts and we'll make a deploy script first.

![sameFunction](/Images/Day9/i48.png)

Our default network is not defined.So in our brownie-config.yaml:

![defaultNet](/Images/Day9/i49.png)

If we run this `brownie run scripts/deploy_lottery.py`, ganache will spin up and nothing will happen because our deploy_lottery function doesn't do anything right now.

**deploy_lottery.py**

First thing we need always to deploy a contract is we need an account.

![get_acc](/Images/Day9/i50.png)

Files inside our scripts directory are:

![FilesInScripts](/Images/Day9/i51.png)

And this is what get_account function looks like in our last project.

![FundMeGetAcc](/Images/Day9/i52.png)

Along with the function we also had imports and vriables.

![importsNvariables](/Images/Day9/i53.png)

**get_account refactored**

Let's flush this out just a little bit more so it's even more robust.Right now we've a way to use brownie's ganache accounts and use our environment variables.However there's a third method that we learned that isn't identified here is accounts.load("id").If you still have your account and you still have all your brownies set, up you could do:

`brownie accounts list`

You could see couple accounts or atleast one.We want our get_account to be even more liberal so that if you wanted to use one of the listed account, we could.Let's modify our get_account script.

First get rid of else and that indent.

![ElseRid](/Images/Day9/i54.png)

What this will do is that this getting from config will be our default.IF nothing that we define prior to this, we'll just default to grab from the config.Since we're doing that let's create our .env file.We'll paste our privatekey, infura and etherscan token here.And in our brownie-config ofcourse we'll:

![fromKey](/Images/Day9/i55.png)

Let's add index and id.

![indexId](/Images/Day9/i56.png)

This way if we pass an index to our get_account function, we'll just use index from accounts variable and if we pass an id, we'll have try to do accounts.load.Let's change a little bit.

![ifIndexId](/Images/Day9/i57.png)

Now we've much more liberal get_account function.So now we've a account we can actually deploy our lottery.

![deployLottery](/Images/Day9/i58.png)

We're gonna have to add in all these different variables so if we go back to our lottery we can see :

![lotteryConstructor](/Images/Day9/i59.png)

We need to give it a _priceFeedAddress, _vrfCoordinator, _link, _fee and a _keyhash.Now the way we did that in fund me is that we did it in way where we check to see if we are on a local chain or not.If we weren't on a local chain then we must pull our addresses directly from our config.If we weren't on a local chain though we'd deploy some mocks and use the address of those mocks.

![Brownie_deploy](/Images/Day9/i60.png)


We're gonna wanna do the same thing here but let's make our lives little bit easier.We can wrap all of the mocking and checking into a single function get_contract which we'll add in helpful_scripts and import it to deploy_lottery.

![getContractDocs](/Images/Day9/i61.png)

If this is little confusing to you we'll go over to chainlink mix in a little bit and inside of this has a more robust description of what's going on this get_contract.You can check that out if you want to learn more.

So we obviously want contract name as a parameter.Meaning that this get_contract function will get something like:

`get_contract("eth_usd_price_feed")`

That's gonna be the same as what's defined in our brownie-config.yaml file.From this name we're gonna get the type of contract that it is.To do that we're gonna have to create some mapping that'll map the contract names to their type.

**contract_to_mock**

![contractToMock](/Images/Day9/i62.png)

eth_usd_price_feed is gonna be of type MockV3Aggregator and also we need to import MockV3Aggregator.

Now we need to check do we actually need to deploy a mock.Let's check if we're on a local blockchain.And we'll skip the forked local environments because again we don't need to deploy a mock pricefeedAddress on a forked local environment.Also we'll check if one of the contracts in contract_type has been deployed or not.

![checkingMocks](/Images/Day9/i63.png)

`if len(contract_type)<=0 is equivlent to MockV3Aggregator.length`

We're checking how many MockV3Aggregators have actually been deployed.If none of them have been deployed, we'll be deploying them.

We're gonna have to create this deploy_mocks function which is going to be same as what we did in our brownie FundMe.

![deployMocks](/Images/Day9/i64.png)

Now we have a way to actually deploy the mock pricefeed.Let's go back to our get_contract function.So we have a way to deploy the mock if one isn't deployed.Now what we're gonna want to do is we want to get that contract.WE want to get that mock.

![recentContract](/Images/Day9/i65.png)

This is saying let's grab the most recent deployment of the MockV3Aggregator which is exactly what we want.This will work perfectly for our development context.However we're not always going to just want to deploy to a development network.We're also going to want to deploy to testnets.

![contractAddress](/Images/Day9/i66.png)

For example if it's eth_use_price_feed, contract_name will be eth_usd_price_feed and the way we're setting it up it's got to be the same as what's in our contract_to_mock dictionary.Inside If the way we did it was we actually got the contract because we had it's contract type based off of brownie.Here we've to interact with the contract getting those two pieces that we always need:

- Address
- ABI

We actually have the ABI from our MockV3Aggregator type and we just got the address.So we can create the new contract type.

**Contract.from_abi**

![contract_abi](/Images/Day9/i67.png)

This contract package can be imported from brownie and it has this function from_abi that allows us to get a contract from it's abi and it's address.

![imports](/Images/Day9/i68.png)

We gave it a name(contract_type._name)

MockV3Aggregators and all these contracts have a .abi attribute that returns the abi.
They also have ._name which returns their name.

This is how we'll get the contract otherwise.And then at the end of all this we'll just return contract.

![finalGetContract](/Images/Day9/i69.png)

This is an incredibly powerful function for us to get a contract based off of if it's already deployed as a mock or it's a real true contract.

Now that we've this function let's go back to our deploy_lottery.

![lotteryDeplotGetAccount](/Images/Day9/i70.png)

Let's go this again.This Lottery.deploy get_contract is gonna get an eth_usd_price_feed.If we don't have a mock deployed, it's gonna deploy a mock pricefeed for us and we're goint to return that mock pricefeed.However if we're on a testnet or a real network, we're gonna grab it's actual address and return a mock contract of it.Our mock contract has all the same functions of a regular contract.So we can just use it as the same.This way we don't have to adjust deploy_lottery function for whether or not we're deploying to a testnet or to an actual address.

The only additional piece we should put in here just for clarity is we should add .address because get_contract is gonna return the actual contract and we really only want the address.

![address](/Images/Day9/i71.png)

This is going to make our coding alot more robust for moving between development environments and testnet environments and working with scripts in a really effective manner. 

Let's go back to lottery and figure out what are the different pieces we need.

![lottery_Constructor](/Images/Day9/i72.png)

We also need a _vrfCoordinator.

So to do this we're gonna go back to docs.chain.link, then to [contract addresses](https://docs.chain.link/docs/vrf-contracts/) and we could do mainnet here but let's also just set this up to work with rinkeby.We'll copy the address of Rinkeby's vrfCoordinator and add it to a new network in config file and while we're doing this let's also get the rinkeby address for our [pricefeed](https://docs.chain.link/docs/ethereum-addresses/), grab the address for eth/usd and add it in a config file. 

![vrfandPricefeed](/Images/Day9/i73.png)

**Adding vrfCoordinatorMock**

Now we can do to get vrfCoordinator contract address.

![vrfAddress](/Images/Day9/i74.png)

Ofcourse we're gonna have to go back to our helpful scripts because there's currently no mapping between what a vrf_coordinator is and what it's mock needs to be.We need to get a mock vrf_coordinator.First of all we don't even have our MockV3Aggregator.So let's go grab that as well.We can grab both of these at [chainlink-mix](https://github.com/PatrickAlphaC/smartcontract-lottery/tree/main/contracts/test).Let's go to VRFCoordinatorV2Mock and grab whole thing and create new directory "test" inside contracts and inside test create "VRFCoordinatorMock.sol" file and past the code there.Also create file for MockV3Aggregator and past the code.

VRFCoordinatorMock has different functions for actually working with the vrf_coordintor.One of the specific ones in particular is this callback with randomness that we're going to use in our tests.So our vrf_coordinator is also going to get mapped to our VRFCoordinatorMock and we'll also import it from brownie.

![vrf_Coordinator](/Images/Day9/i75.png)

Just to double check everything's working we wanna run quick `brownie compile` to make sure we're importing our mocks correctly and everything is compiling.

We need a link token now.The chainlink token is just another smart contract.So we're gonna do the exact same thing here.

![linkToken](/Images/Day9/i76.png)

This means in our config for rinkeby let's add a link token address.Go to chainlink documentation and to [link token contract](https://docs.chain.link/docs/link-token-contracts/), grab the address and put it in config file.

![link_token](/Images/Day9/i77.png)

Now we've it in our brownie-config.We also need to add it to our helpful_scripts.We need a mock link token for that which we can get from [here](https://github.com/PatrickAlphaC/smartcontract-lottery/blob/main/contracts/test/LinkToken.sol).We can just go ahead and grab everything, create a new file "LinkToken.sol" inside test folder and past it inside the file.In our helpful_scripts we're gonna map link_token to LinkToken and import LinkToken from brownie.

![linkTokenMap](/Images/Day9/i78.png)

We need a _fee and a _keyHash.The _fee and the _keyHash are both just numbers.These aren't actually contracts.We don't need to put this through get_contract bit.What we can do is just in our config, in our development network, we just add a default for the keyHash and fee.I'm just gonna set my development keyhash and fee equal to the rinkeby ones.You can grab these from [here](https://docs.chain.link/docs/vrf-contracts/v1/).

![keyHashFee](/Images/Day9/i79.png)

In our deploy_lottery we can just grab this directly from a brownie config because we're always gonna have the default keyhash and fee.

![depFee](/Images/Day9/i80.png)

Then ofcourse our last bit here.

![account](/Images/Day9/i81.png)

Then additionally as we learned last time if we want to publish this :

![publish](/Images/Day9/i82.png)

What this is saying is get that verify key but if there's no verify key there just default to false.This way if we don't set a verify key in development, that's fine it won't get verified.For rinkeby set verify to true.So we can actually verify this on a rinkeby chain.

Alright let's try this out.We'll do :

`brownie run scripts/deploy_lottery.py` for default development network

We run into this error.

![error](/Images/Day9/i83.png)


We get an issue with our get_contract function.We forgot to add deploying the mocks in our deploy_mocks function.Right now our deploy_mocks only deploys the MockV3Aggregator.Let's add the rest of the mocks in here.We're gonna need to deploy VRFCoordinatorMock and LinkToken.So let's open up those contracts see what they need.LinkToken doesn't have a constructor.We can just have it to be blank.

![LinkTokenDeploy](/Images/Day9/i84.png)

Let's see what that VRFCoordinatorMock takes.

![VRFConst](/Images/Day9/i85.png)

It takes the link token as an address.

![finalDepMocks](/Images/Day9/i86.png)

Let's try again deploying it again.

![Output](/Images/Day9/i87.png)

We can see that our MockV3Aggregator was deployed then our LinkToken was deployed then our VRFCoordinatorMock was deployed and then our lottery was deployed with those mocks defined.We deployed the lottery.

We could 100% go ahead and then run this script on an actual testnet because our config is set up well.Let's write more functionality for actually interacting with this lottery before we actually do that and then we can actually just run a script which will do all this functionality end to end because again deploying to testnet takes long time and we really only want to do that when we're done and fairly confident that everything's working well.

**Python Lottery Scripts/Functions**

What's the next thing that we'd want to do?Well we probably want to go ahead and start the lottery.Let's write a script that can actually do that.

**Start Lottery**

![start_lottery](/Images/Day9/i88.png)

We said that the lottery is gonna be the most recent deployment of the lottery and we're gonna call startLottery function of Lottery.sol.It is indeed changing state.So we do have to make a transaction.Then in our main function we call the start_lottery function.So if we run this again on our development chain.

We did run into an issue and this is something you'll see something from time to time.

![Error2](/Images/Day9/i89.png)

Typically workaround is you wanna wait for that last transaction to actually go through.So we'll say:

![txnWait](/Images/Day9/i90.png)


**enter_lottery**

Next we wanna do is enter the lottery.We need to pick some value to send when we call the enter function because we need to send the entranceFee with it and just to be safe I usually will tack on a little bit of wei as well because sometimes it might be off by like 1 or 2.

![enter_lottery](/Images/Day9/i91.png)

**end_lottery**

Before we actually end the lottery, we're gonna need some link token in this contract because our endLottery function calls the requestRandomness function.We can only requestRandomness if our contract has some chainlink token associated with it.So we're gonna need to first fund the contract and then end the lottery.

**Funding with LINK**

Since funding our contracts with the link token is gonna be a pretty common function that we use.Let's go ahead and turn this also into a helpful_scripts.

We have a contract address then we wanna who we're gonn fund with link.We'll set default account to be none.We'll do same with the link token as well.If you want to use a specific link token you can otherwise we'll just grab it ourselves and then we'll also do a default amount which will set to 0.1 LINK.

![fund_with_link](Images/Day9/i92.png)

First we get an account.We'll be doing a little clever python stuff.We'll say account = account if somebody sent it otherwise we'll call our get_account function.Then we'll do the same thing with the link token.Now that we've the link_token contract from our get_contract function which again is basically the equivalent of Contract.from_abi on our link token, pulling from our config or from our mock.Now we can just call functions on the link_token.We're gonna transfer token to contract_address with a certain amount and from account. 

![fundingLink](/Images/Day9/i93.png)

**brownie interfaces**

I do however wanna show you another way to work with this.Using the interfaces.Instead of doing the link_token.transfer directly on the contract, we can use the interfaces section to actually interact with some contracts.Right now we've our LinkToken inside contracts/test directory and it has all the definations and all the functionalities defined.Sometimes you're gonna have contracts that you don't have everything.You don't have all the functionality and maybe only have the interface or some functions definitions.So we can still interact with contracts with just an interface because again that interface will compile down to our ABI.

So as a another way of teaching us how to actually work with some of these contracts, what we can do is we can use the link token interface basically the same way as we use the link token contract [here](https://github.com/PatrickAlphaC/smartcontract-lottery/blob/main/interfaces/LinkTokenInterface.sol).This will compile down to a way that our brownie package knows how to interact with these contracts.If you wanted to, you can just grab it, go to our brownie sections and inside interfaces, create a new file "LinkTokenInterface.sol" and paste the code.

What we can do in our helpful_scripts instead is first import interface from brownie and pass contract address. 

![AnotherWay](/Images/Day9/i94.png)

This is an another way we can actually create contracts to actually interact with them.So saw up in the code that Contract.from_abi which is great and interface is another way we can do the exact same thing.

If we've the abi, we can just pop it into Contract.from_abi.If we've the interface we don't even need to compile down to the abi ourselves because brownie is smart enough to know that it can compile down to the abi itself.

For now I'm gonna comment these two lines though and we'll just use the link_token.transfer for now.

Now that we've a funding function we can import fund_with_link from our helpful_scripts.

![FinalEndLottery](/Images/Day9/i95.png)

We're only passing contract_address in a fund_with_link functions because the way we've set the function will just automatically grab a default otherwise.And Once we were funded with link, we called endLottery function because again this is going to call that requestRandomness function from the chainlink vrf.

**waiting for callback**

From our end this is really all that we need to do but remember when we call the endLottery function, we're gonna make a request to a chainlink node and that chainlink node is going to respond by calling the fulfillRandomness function.So we actually have to wait for that chainlink node to finish.Typically it's within a few blocks.So normally what we can do is sleep for some time and we also need to import time.

We can see who that recent winner is if that chainlink node responded with a recent winner.

![winner](/Images/Day9/i96.png)

You might be thinking "There's no chainlink node watching our local ganache" and you're exactly correct.

What happens when we add our end_lottery function to our main function? Do you think that we're actually gonna get a recent winner back?Let's give it a shot.

`brownie run scripts/deploy_lottery.py`

While we're waiting here, this is when a chainlink node would go ahead and stat responding with our randomness.However as you probably astutely telling there's no chainlink node that's going to call this fulfillRandomness function right now.So for our ganache chain this will hypothetically end with nothing because there's no chainlink node actually responding.


For our testing purposes we're gonna figure it out how to actually get around that end the deal with that.We want to make sure that our tests are really solid on a development chain before we actually test this on an actual testnet.So let's jump into some of these tests.

We've already started with test_lottery.py but we're gonna iterate on this and make this even better.Now before we get into these tests there's a couple of things we wanna talk about.

**Integration Tests Vs Unit Tests**

Unit tests is a way of testing the smallest pieces of code in an isolated instance.We're going to use it loosely define testing independent functions in our lottery contract.

We also want to do integration testing which is gonna be testing across multiple complex pieces.Typically I like to run my unit tests exclusively on a development environment and my integration tests on a testnet.This is really helpful because we can test the majority of our application like we said on a development network and then still be able to see what actually happens on a real testnet and etherscan.

Typically what people do is in their test folder they'll create two different folders.One for unit and another for integration.Since for this demo we're only going to have one file for both.I'll not create those folders but it's pretty common practice.Instead I'm gonna rename the test file "test_lottery.py" to "test_lottery_unit.py" for unit tests and we're gonna create a new file called "test_lottery_integration.py".

**Unit Testing**

Now when writing the unit tests we really wanna test hypothetically every single line of code in our smart contract.This is incredibly important of course because smart contracts are open to everybody to see and interact with.So we really want to test every single line of code we've in Lottery.sol file.

Let's go ahead and finish writing a getEntranceFee test that will work on a local development network.As you can see we're already gonna refactor our test_get_entrance_fee function.So delete everything inside that function.

First we need to deploy our lottery.Since we've a deploy_lottery script already, we can just use the deploy_lottery script as well.If we wanted to we could just copy paste the whole code inside deploy_lottery function into our test but we'll work from the deploy_lottery script.

![deploy_lottery](/Images/Day9/i97.png)

Now we import the deploy_lottery function.

![importing_deploy_lottery](/Images/Day9/i98.png)

And in our unit test we'll say:

`lottery = deploy_lottery()` which will give us our lottery.

Once we've our lottery contract, we can just call getEntranceFee.

`entrance_fee = lottery.getEntranceFee()`

And we wanna make sure the entrance_fee is what we expected it to be.So what we expect it to be? Well again in our helpful_scripts is going to deploy mocks and the initial_value is 2000.So if the price of eth is 2000 eth/usd, and the usd entry fee is 50, we'd say 2000/1 == 50/x  == 0.025.We can go ahead and even do the math in the script.

![get_entrance_fee](/Images/Day9/i99.png)

And to test it we'll do `brownie test -k test_get_entrance_fee`

This is working exactly as we anticipated.

**pytest.skip**

As we mentioned since this is a unit test, we really only want to run this when we're working  on a local blockchain environment or local development network.So we'll go ahead and do this with pytest again.

![pytest](/Images/Day9/i100.png)


If you try to run this `brownie test -k test_get_entrance_fee --network rinkeby`, it should skip the test.

**test_cant_enter_unless_started**

Enter if going to be the first thing that these developers do.We can be more specific than that.We don't want people to enter our lotteries unless the lottery is actually started.So we make sure `require (lottery_state == LOTTERY_STATE.OPEN)` of enter function actually works.

![CantEnterUnlessStarted](/Images/Day9/i101.png)

Now when people try to enter a lottery that hasn't started yet it's gonna revert.

![revert](/Images/Day9/i102.png)

And ofcourse we gonna have to import get_account from scripts.helpful_scripts and exceptions from brownie.

Let's go ahead and test this `brownie test -k cant_enter_unless_started`.That'll pass as well.

**test_can_start_and_enter_lottery**

We've tested whether or not they can't enter.Let's test whether or not they can enter.

![test_can_start_and_enter_lottery](/Images/Day9/i103.png)

We asserted to check that we've correctly added a player to the lottery because we've our players array and we're asserting that pushing them onto our array correctly.Let's try this now `brownie test -k test_get_entrance_fee`.

**test_can_end_lottery**

Let's test to see if we can actually end a lottery.

![endLottery](/Images/Day9/i104.png)

Now we actually end the lottery we do need to send the link because we're calling requestRandomness.We use our fund_with_link function that we've in our helpful_scripts.We'll call fund_with_link on our lottery contract.Once we fund with link we'll then call endLottery.

![fundLink](/Images/Day9/i105.png)

Then how do we actually know that endLottery is being called correctly?Well if we look back in our lottery contract.When we call endLottery, we're not doing a whole lot.All we're doing is changing our state.So let's go ahead and check to see if our calculating_winner state is different.

![checkingEndLottery](/Images/Day9/i106.png)

Calculating_winner is in position 2.

**test_can_pick_winner_correctly**

Now let's test the most interesting piece of this entire lottery contract.We're gonna test whether or not our fullfill function actually works correctly.Does fulfillRandomness function of Lottery correctly choose a winner?Does it correctly pay the winner?Does it correctly reset?

Let's go ahead and build our most complicated and most important test of this whole contract.

![GettingAcc](/Images/Day9/i107.png)

These are going to be different accounts because we want to test for multiple different people.This unit test is getting drastically close to being an integration test but as I said we're being a little bit loose with the definitions.Now we're gonna want to fund it with link and now we're gonna choose a winner here.This is where we actually have to modify one more thing in our lottery contract.

**Events and Logs**

In order to test actually calling this fulfillRandomness function and testing everything in here, we're going to need to call this fulfillRandomness function.If we look in our VRFCoordinatorMock, we've this function called callback with randomness and this is the function that actually calls this rawFulfillRandomness.selector which eventually will call that fulfillRandomness function but this is the entry point that the node actually calls.We've to pretend to be a chainlink node and call callBackWithRandomness function.We're gonna return a random number, choose the contract we want to return to but we also have to pass the original request_id associated with the original call.

Now in our lottery contract, our endLottery function isn't gonna return anything and even if it did, it'd be really difficult for us to get that return type in our Python.So what we wanna do is to keep track of when this contract actually entered the calculating_winner state is we want to do what's called `emitting an event`.

Events are pieces of data executed in the blockchain and stored in the blockchain but are not accessible by any smart contracts.Events are much more gas efficient than using a storage variable.You can kind of think of them as the printlines of blockchain.

You can go to the logs section in etherscan which also includes all the different events.We're actually going to do an event ourself just so that we can see what this really looks like.

![event](/Images/Day9/i108.png)

When we called endLottery function, in the logs if we scroll to the bottom, there's an event here called `RandomnessRequest` which was spit out by the vrfConsumerBase that we inherited and it even has some data that's already been decoded.One of those pieces of data is the request_id.

Now to add an event we first need to create our event type.

![eventType](/Images/Day9/i109.png)

Now we've identified a new type of event called RequestedRandomness.It's really similar to enum in this regard.To omit one of these events, all we've to do in our endLottery bit is we'll emit RequestedRandomness.

![emit](/Images/Day9/i110.png)

Because RequestedRandomness takes a bytes32 as an input parameter and we're gonna pass it that requestID as an input parameter.Now that we've this event being emitted, back in our test when we call endLotter, it'll actually emit one of these events to our transaction.

![requestId](/Images/Day9/i111.png)

Txn has a attributes called events which stores all of our events.We can then looked for a certain event name which we know is RequestedRandomness and in there in that RequestedRandomness event find the requestId.

These events are really helpful for writing tests, upgrading our smart contracts or understanding when a mapping is updated.

Now that we've this request_id we can pretend to be the chainlink node and use this callBackwithRandomness function to dummy getting a random number back from the chainlink node.So we're gonna call our get_contract function to get that vrf_coordinator and we're gonna callback with callBackWithRandomness function.

**callBackWithRandomness**

We need to pass the request_id of random number and then the contract to return to.STATIC_RGN is some random number which is the random number that we're gonna return and lottery.address because we're gonna return it to the lottery.From account because it's making a state change.

![callBack](/Images/Day9/i112.png)

This is us dummying getting a response from a chainlink node and this is how we mock responses in our tests to make our lives way way easier.

Now that we've got our callback we can do our asserts.We can figure our who the winner of the lottery actually is.There are 3 entries that means it's 777 % 3 = 0 i.e our account is gonna be the winner.

![assert1](/Images/Day9/i113.png)

We transfer them some money

![assert2](/Images/Day9/i114.png)


Test this function out.

So go ahead and do our last bit.Create our integration test which we'll run on an actual chain and then if we wanted to we go ahead and try our deploy_lottery function on a real chain as well.

**Integration Test**

This is where we're actually going to test on a real live chain.We're gonna use rinkeby because that's the network that we've been using this whole time.Now I'm being a little bit liberal in the way that we're doing our tests here and we're just gonna do one test for this integration test but keep in mind you're gonna test every piece of your code.So let's just create a test.


This is going to be opposite of our unit test.Our unit tests only going to be on our local blockchains.We're gonna skip if it's not on our local blockchains.We're gonna do the opposite of pytest.skip thing.

![pytestSkip](/Images/Day9/i115.png)

Rest will be similar like we did in unit test.

![integrationEndLottery](/Images/Day9/i116.png)

account is twice cause we want two people to enter the lottery.

After endLottery is where this is gonna be a little bit different from our unit tests.In our unit tests we pretended that we're the vrfCoordinator and we called the callback with randomness.We pretended that we're a chainlink node.But here we're not a chainlink node because we're on a actual network.So we're just going to wait for that chainlink node to respond.So for simplicity we'll just do  `time.sleep(60)` for it to respond.And since we're using time, we need to import it.And then since account was the only one to actually be in this.so we'll do assert for it.Also we'll do assert for balance.

![IntegrationAssert](/Images/Day9/i117.png)


we've an integration test which is going to run through pretty much vast majority of our functionality here.We can go ahead and test this with `brownie test -k test_can_pick_winner --network rinkeby -s` and before we run this we need to make sure we've test ethereum and link.-s flag will print out whatever brownie is going to print our.

**Test deployment**

Now that we've added our test, we can run our entire test.

for development `brownie test`

for testnet `brownie run scripts/deploy_lottery.py --network rinkeby`

![outputOfIntegrationTests](/Images/Day9/i118.png)

First we go ahead and deployed our lottery.We got our addresses with our get_contract method, got our fee, keyhash, published_source and everything.Then we went ahead and verified it because it has this published_source.So if we grab the address "lottery deployed address", jump over to rinkeby etherscan, past the address in there we'll see the contract is checked mark.If we go to the read contract, we can see all the public variables and all public functions.We can go to write contract and see all the transacting functions that we can interact with.

After we get verified and things get deployed we went ahead and called our startLottery function to actually start the lottery then we entered lottery.We then funded the contract with linkSo we can get our random winner back.Right now our endLottery is confirmed and we're just waiting this 60 seconds because we did time.sleep.We can see on the transaction of that deployed lottery address in rinkeby etherscan, you can see different methods calls.

![txn](/Images/Day9/i119.png)

We can also go to events and we can see some events that we created.

![eventsAfterLottery](/Images/Day9/i120.png)

We can see the first event is RequestedRandomness event.This is the event that we called.We can also see an OwnershipTransferred function that got called when we actually deployed this in the first place.

**Topics**

So topic 0 hash represents entire event.Hash near Hex is our topic 1 which represents that requestId.That is the requestId.

**Conftest.py**

One additional piece that I wanna talk about again in our testing a file that you often gonna see is "conftest.py".Python automatically knows to look for this conftest file and we'll grab different functions from it.We can also add external plugins, fixtures, hooks and test root paths.It adds alot of fantastic features and is a common thing that you'll see.We skipped here for simplicity but in future projects you'll probably see this conftest file which has alot of really nice testing configuration pieces. 


## Lesson 8: Chainlink Mix

That was a lot of stuff to code and quite frankly I don't think any of us want to have to do that every single time have to code everything from scratch.There's actually even easier way first to start with a blank project here and this is with [brownie mixes](https://github.com/brownie-mix).It has ton of boilerplate code for us to go ahead and get started to start start developing.The one we're gonna be working with is chainlink-mix piece.This gives us some wonderful contracts, tests, brownie config and really everything we need to do to get started.If you've brownie installed, you can just bake this mix.

`brownie bake chainlink-mix`

We'll get new chainlink folder with everything inside of it.In contracts we've a whole bunnch of different samples of working with the vrf, pricefeed, keepers to automate our smart contracts and making api calls and delivering any api call that we want to the blockchain.It also has a brownie config which already has a number of wonderful pieces in each networks.So that we don't have to go copy paste and add it in here.It's even got support for testnets like avalanche, polygon, binance and more.It has a number of really powerful tests including testing some pricefeeds.It has whole bunch of deployment scripts, some mocking scripts, some helpful scripts and really everything that we need to get started and get going.For starters we can run  `brownie test` and it's going to compile everything and then on a development chain run all the unit tests and if we want to test on a real testnet, we could do `brownie test --network rinkeby`

If you're looking for a good starter place that has alot of really powerful smart contracts for you to get started, I highly recommend using this mix as a boilerplate starting point for any of your contracts or any of your projects.


## Lesson 9: ERC20s, EIPs, and Token Standards

We've learned a ton of fundamentals of working with brownie and smart contracts.Now that we've kind of all the building blocks though we can actually code alot of these much faster and much more efficiently than before.

One of the things that we've seen over and over again is working with tokens and the ERC-20 token standard.We're going to learn how to build our own token.Before we do that let's understand why we'd even want to do this.

![tokens](/Images/Day11/j1.png)

ERC20s are tokens that are deployed on a chain using what's called the ERC20 token standard.You can read more about ERC-20 token standard [here](https://eips.ethereum.org/EIPS/eip-20).Well basically it's a smart contract that actually represents a token.So it's a token with a smart contract.It's both.Tether, chainlink, uni token and dai are all examples of ERC-20s.Technically chainlink is in the ERC677 as there as upgrades to the ERC20 that some tokens take that are still backwards compatible with ERC20s.So basically you can think of them as a ERC20s with a little additional functionality.

**Why make an ERC20?**

- Governance Tokens
- Secure an underlying network
- Create a synthetic asset


**How do we build one of these tokens?**

All we have to do is build a smart contract that follows the token standard.Build the smart contract that has functions like name, symbol, decimals etc as mentioned in [here](https://eips.ethereum.org/EIPS/eip-20).We need to be able to transfer it, get balance of it etc.Again if you want to check out some of the improvements that are still ERC20 compatible like the ERC677 or the ERC777, you can definitely check those out and build one of those instead.Let's create our new folder and get started.To create new brownie file:

`brownie init`

It's going to startup our repository and everything that we're going to work with here.We can kind of actually just jump in and start with our contracts.Let's create a new file inside contracts directory called "OurToken.sol" and this is where we're gonna add all of our token code.

Since [this](https://eips.ethereum.org/EIPS/eip-20) is an EIP, we could grab all the functions and past them inside our file "OurToken.sol" and then you know code all these up like these does some stuff blah blah.Or we could do it the much easier way.Since we're engineers we don't always want to reinvent the wheel.So once again our friend OpenZeppelin have some amazing [contract packages](https://docs.openzeppelin.com/contracts/4.x/erc20) for building our own ERC20 token.

![ERC20](/Images/Day11/j2.png)

This is the entirety of the code that is needed to make an ERC20.We can copy and paste this.Boom we've our ERC20 token.Let's actually change the name of everything here though.We're gonna be using solidity version 0.8 which I know I've done alot of this in 0.6 but I highly recommend working with 0.8 because it has a lot of really fantastic improvements to solidity.

**Solidity 0.8**

You'll notice this is our first dive into using a different version of solidity.You'll notice that most of the syntax is exactly the same.There are like I said couple of nice improvements with 0.8.The main one being you no longer have to use those safeMath functions that we talked about before.

Then we go ahead and import openzeppelin.Since we're importing openzeppelin, we're gonna add this to our brownie config and before we even get started, you technically have all the tools that you need to code and deploy your own ERC20 token.

Now I'm actually gonna challenge you to go ahead and try to start a brownie project, create your own token using openzeppelin packages and then deploy it on a testnet.I'm going to show you how to do all of it anyways but challenging yourself and trying to do things your own way and exploring is really one of the fastest ways to learn and grow in this space.

We need to add dependencies in our brownie-config file.

![dependencies](/Images/Day11/j3.png)

If you go to Github of [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts), you can see the latest release.4.5.0 is the latest relaease at this time.So I used it.

![openZeppelingVersion](/Images/Day11/j4.png)

Now we can import ERC20.sol contract from OpenZeppelin.Let's change the contract name to OurToken which we're going to inherit from [ERC20 from OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol).In our constructor, we're going to add our initial supply which is going to be in a wei and we're going to use the constructor of ERC20.It uses name and a symbol.We'll give a name to our token as "OurToken" and the symbol we'll do "OT".This is literally all we need for our token here.

![OurToken](/Images/Day11/j5.png)

**1_deploy_token.py**

For scripts all we have to do is create a new file "1_deploy_token.py" and "helpful_scripts.py".We'll quickly add get_account function in our helpful_scripts.You can go ahead and just copy paste from the last one.And to make sure add __init__.py inside scripts folder too.

![helpfulScripts](/Images/Day11/j6.png)

Now in our deployment token script,we'll do our imports.

![imports](/Images/Day11/j7.png)

Since we knoe that we need an initial supply in our "OurToken" contract, let's go ahead and go that.

![tokenDeployment](/Images/Day11/j8.png)

If you don't have your environment variable set, add your .env file where you can add private key, web3 infura project id and ether scan api.And then last but not least we'll add .env in our config.If you want to actually deploy this to testnet, you need to make brownie know where to grab private key from.

![privateKey](/Images/Day11/j9.png)

We can run the scripts

`brownie run scripts/1_deploy_token.py` and you will see our token is printed out.

![output](/Images/Day11/j10.png)

We can see we've our token deployed on our local ganache.I can run this again on rinkeby.

![rinkeby](/Images/Day11/j11.png)

Grab the address and go to rinkeby etherscan, pop it in and after quick refresh, You can see contract been added.You can even go to your metamask then to assets, add the address to our metamask, add the token and you'll see you'll be the owners of "OurToken".

**Don't do this now**

Something else you might wanna do is add this to a liquidity pool or add this to a place where you can actually go ahead and sell it and put it on the market.You can do something like that as easily as just popping onto uniswap, going to pool, hitting more, creating a pool and then adding our token.We'd have to manage the token list and be sure to add the token, create our own pool and automatically put it on uniswap.That's how easy it is to actually sell it on one of these pools.


##  Lesson 10: Defi & Aave

I thought we know a little bit more about Defi and why it's such an amazing technology that only works in the blockchain world.Let's look at this site [defi pulse](https://www.defipulse.com/) or if you want to look at another one called [defilamma](https://defillama.com/) which also shows alot of different protocols.So defipulse is an application that shows some of the top defi projects based on how much total asset is locked into each protocol.Aave which currently is the number one ranked defi application with 9.32 billion in assets under management in terms of USD.We've some fantastic ones like curve, compound, maker, InstaDApp etc.Now we're gonna be looking at two of these protocols in particular.The first one ofcourse being Aave and second one is gonna be what's called a decentralized exchange "paraswap".You start with aava.We're going to go to [testnet.aave.com](https://staging.aave.com/) that looks something like this with please connect your wallet and everything will be pretty empty.

**Decentralized Exchange(DEX)**

[Paraswap](https://app.paraswap.io/#/?network=ethereum) is what's known as a dex or a decentralized exchange.It allows us to trade tokens incredibly easy on the blockchain.Now there's not a whole lot of testnet indexes that actually work.So we're just going to look at them and simulate as if we're working on them.For example if I wanted to trade 1 eth for some usdt or maybe some wrapped bitcoin or some dai or some aave or really any token that we wanted, all we need to do is connect to our wallet and swap button would show up and we could go ahead and hit swap.Some of these really powerful these dexes and really popular ones are going to be curve finance, uniswap and it's really really easy way to go ahead and swap your tokens for one another depending on what you're looking to do.

Aave is incredibly powerful and it's going to be one that we're going to be working alot with because it has pretty much all the fundamentals of working with the defi protocol that we're looking for and it has a [testnet](https://v3-test.aave.com/#/dashboard) that we can go ahead and test and simulate actually working with some of these protocols.So we're gonna first work with the UI or the user interface and then we're going to do everything here programmatically.

**Get some Kovan ETH**

First things first if you don't already have it make sure you've some testnet ethereum at least.You can get some testnet ethereum from looking at the [link token contracts](https://docs.chain.link/docs/link-token-contracts/) and going to Kovan.Once we see some eth in our Kovan testnet we can go back to aave.So whereas paraswap allows you to simply swap between assets and do a lot of buying and selling of tokens, aave is a lending and borrowing application.So we can actually put down a token as collateral and we can borrow and we can generate some yeild from interacting with this protocol.Borrowing and lending is a critical piece to doing any type of really interesting financial applications or financial instruments such as short selling, being exposed to more assests etc.You can also gain some percentage back.

![apy](/Images/Day12/k1.png)

If you look at apy, it'll tell you how much percentage over a year you'll actually get in returns from staking or depsiting an asset.We're gonna connect the application using metamask and you'll see on a asset to supply, we can see our balance.

**Depositing tokens/ Lending**

What we can now do is click on ethereum, click on max button to deposit some ethereum, hit continue and a little dashboard will pop up asking us "would you like to deposit?".Clicking the deposit button will actually have us deposit right onto the aave contract on the Kovan testnet.Make sure once you hit the deposit that you're actually on a tetnet.

![depositEth](/Images/Day12/k2.png)

I did it on a rinkeby testnet.Idk why my Kovan isn't working while doing this.

![aaveDeposit](/Images/Day12/k3.png)


**WETHGateway**

Funnily enough you'll see that this is the WETHGateway.

![WETHGateway](/Images/Day12/k4.png)

When we deposit our Rinkeby Eth, it actually gets transferred into an ERC20 version of our Ethereum and then it'll go ahead and deposit in into the aave contract.

**Interest Bearing Token (aToken)**

aETH is what's called an interest-bearing token and it goes up in real time.You'll see if eth amount going up if I looked my wallet for longer period of time.This is the profit given to us from other people borrowing the ETH that we've deposited into aave.If we go to our dashboard now,

![ETHDeposited](/Images/Day12/k5.png)

We can see we've 0.393 ETH deposited and if you roll over it, you'll constantly see amount go up and up.We can go ahead and withdraw our eth which will convert our aETH back into ETH with the additional interest that we got from depositing.So depositing into aave will give us interest back as a payment for other people borrowing the ETH that we've deposited.We can also use this ETH as what's called collateral.

If I go to the borrow tab, I can actually use the ETH to borrow some other asset.Maybe I wanna borrow dai which is a stable coin meant to always equal one dollar.USDC and USDT also are meant to always reflect a dollar.We can borrow what's called wrapped bitcoin(WBTC) which represents the Bitcoin price.

**Why borrow?**

Now borrowing as asset is incredibly incredibly powerful.By borrowing you're allowed to obtain liquidity without selling your assets and borrowing is one of the first pieces in order to actually short sell.Borrowing in defi protocols is absolutely massive because it allows you to:
- Frictionlessly short sell
- Obtaining liquidity without closing your positions
- Gaining yeild on some deposited collateral
- Massive number of new things only in defi world such as flash loans

`Important Note`:
                Since we're just borrowing on testnet and this isn't real money.This is 100% okay to experiment with and work with.However if you borrow an asset and you do not pay attention to how much you've for an underlying collatera, you could get liquidated and loose some of your funds.So be very careful and pay alot of attention if you're gonna do this on an actual network.
                
Let's say we wanna borrow aave token for example.We click into aave and we choose the amount we want to borrow.Since we've placed down some collateral 0.3ETH, if the amount that we borrow ends up being too high, we'll actually get what's called liquidated.Everytime we borrow an asset, we get some type of health factor.The health factor represents how close to being liquidated you're.Once your health factor reaches 1, the collateral that you've actually deposited will get liquidated and somebody else will get paid to take some of your collateral.This is so that the aave application is always `solvent`.Being solvent means It's never in debt.

When I wanna borrow I want to choose some amount that might be a little bit safe here.So that I'm not going to get liquidated.I'm gonna choose some number where I see a health factor maybe like 5.4.

![healthFactor](/Images/Day12/k6.png)

and hit continue.Now we'll have to choose our interest rate.

![Interest](/Images/Day12/k7.png)

**Stable Vs Variable Interest Rate**

When we borrow an asset, we actually have to pay some interest.This payment is actually going to go to the people who are depositing the asset.The interest rate that we're gonna pay is actually gonna be paid to those who are depositing the asset that we're borrowing.So like how we're getting interest on our deposited collateral, others are getting interest on their deposited collateral based off of how often people are  borrowing it.We choose a stable apy which will always be 9.42% or a variable apy which will change based off of how volatile and how in demand this asset is.For now I'm going to choose variable but you can pick whatever you want.Same interface is gonna show up so hit borrow, metamask is gonna pop up and ask us if you really want to borrow.We're gonna hit confirm.

![success](/Images/Day12/k8.png)


We've successfully borrowed link into our application.We can even hit this liitle add link to your browser wallet button, to add the token to our wallet.We can now see link is indeed in our token assets.If we go back to our dashboard, you'll see we've health factor score.

![healthFactorScored](/Images/Day12/k9.png)

This is a really important score.If you click on the little i thing, it says:

![Ithing](/Images/Day12/k10.png)

We'll see all of our deposits here.We've 0.393 ETH deposited and 16 LINK deposited.You'll see whole lot of stats for working with our application.We can withdraw our ETH, borrow more LINK or we can go ahead and repay.We can either repay from our wallet balance or from our current collateral.Let's go ahead and do from our wallet balance.We'll hit max and continue.We even get this little thing that says you don't have enough funds to repay the full amount.Well why is this the case?We just borrowed the amount.It's because already since depositing, we've accrued a little bit of extra debt.Remember we hit that variable apy and every second it's going to tick up just a little bit.So let's go ahead and pay back what we can with our wallet.

Aave is one of these applications that relies on the chainlink pricefeeds in order to understand the ratio between how much you've deposited as a collateral and then how much you can borrow and take out.

Keep in mind when working with some of this.This is a testnet and we're working is just in a testnet.Sometimes the testnet doesn't work quite as well as mainnet because it's just for testing and doesn't have the exact same support.we were just working on the testnet but if you want to go to aave for real, you can go [here](https://app.aave.com/).Connect your wallet on the ethereum mainnet and interact with it exactly the way we just did.If we're on the mainnet, we can see some additional pieces.

![AaveMain](/Images/Day12/k11.png)

**Reward token / Governance token**

When you deposit something like ETH, you get 0.33% back as interest paid to you for depositing the ETH.You also get a little bit of what's called a governance token.You'll also get a little bit of aave token.I know it's really small but this is an additional incentive that aave has given the users for working with their protocol.Since aave is a decentralized protocol, in order for anything to be improved or anything to be updated on the protocol, it actually has to go through a decentralized vote.So these governance tokens actually dectate and decide how the protocol improves moving forward.

**Programmatic interactions with Aave**

Now that we understand how to work with all of that through UI, let's actually learn how to interact with aave and defi all from our scripts.

**Qunt Defi Engineer**

Learning how to do this way will get us one step closer to being `quantitative defi engineer` or `defi researcher`.This is someone who programmatically does algorithmic trades, algorithmic modelling and just does everything in a programmatic sense making them much more efficient and powerful interacting with defi.

Create a new folder "AAVE_BROWNIE_PY" and open up with VScode to the folder.Let's get into it.

Aave has some fantastic [documentation](https://docs.aave.com/developers/getting-started/readme) that we're gonna be using.

**Aave brownie setup**

Let's go ahead and start with our basic brownie set up.

`brownie init`

**No contract deployments here**

Now for working with brownie we're actually not gonna be deploying any contracts because all the contracts that we're gonna work with are already deployed on chain.All of them are just going to be working with aave.

Create a quick README.md.We can know what we're doing here.

![readMe](/Images/Day12/k12.png)

This will be the full functionality of working with Aave in this deployed contract.But we not do 2.1 for now.

Everything that we're gonna learn here will teach you how to work with other contracts as well such as paraswap or uniswap or any other type of swapping contract that will allow us to buy and sell.

**aave_borrow.py**

So let's just go ahead and create a scripts.We'll call it aave_borrow.py.Let's create a function called main and we'll just do pass for now.

**aave brownie setup**

First thing that we need to figure out how to do is deposit some eth into aave.When we actually deposited our eth via the UI, we could actually see when we call the deposit function, oddly enough if we go to the contract address in rinkeby etherscan, we'll see the address is actually what's called a `WETHGateway`.What aave is doing like I said before is swapping our ethereum for WETH.Again WETH is a ERC20 version of ethereum and this allows to easily work with all the other ERC20s on the aave protocol.

So we actually have to do that as well.

**Converting ETH -> WETH**

So the first thing we're gonna do actually isn't deposit some of our eth, but swap our Eth for WETH.So let's even put this in it's own little script.We'll call it get_weth.py.So we're gonna have a function main and we'll just do pass for now.We actually want to use this get_weth scripts in our aave_borrowed.py.So we actually have a main and we're gonna have get_weth function as well.In our main function you're just gonna call get_weth.

![Setup](/Images/Day12/k13.png)

So how do we actually convert our ethereum to WETH or wrapped ether?

Now to save gas we'd actually interact with the WETHGateway for aave but I'm going to go through how to get WETH in general.We can look up the [WETH kovan contract etherscan](https://kovan.etherscan.io/token/0xd0a1e359811322d97991e03f863a0c30c2cf029c).

![WETHEtherScan](/Images/Day12/k14.png)

We can go to contract and we can see this is indeed verified.

![VerifiedContract](/Images/Day12/k15.png)

The way WETH works is there's withdraw and deposit (on write contract section).We deposit ETH into this contract and it transfers us some WETH.So this is the first contract that we actually want to interact with.So we need our script to be able to call the deposit contract.

So per usual the two things that we need to do this is going to be an:
- ABI 
- Address

**Get the WETH interface**

I really like just doing everything directly from the interfaces.You can get WETH interface from [here](https://github.com/PatrickAlphaC/aave_brownie_py_freecode/blob/main/interfaces/IWeth.sol).Copy and paste it inside the interface directory.You can see this has all the exact same functions as our deposit contract, symbol, name, transfer, pretty much you'd expect from ERC20 plus this extra deposit piece.

So we've an interface now and we also have an address.But again above image has an address on a Kovan network.Since we know ahead of time that we're probably gonna be using this on different networks like mainnet, rinkeby etc, we'll add our brownie-config and add our networks here.

![Kovan](/Images/Day12/k16.png)

We're going to add the rest of the pieces.

![wallets](/Images/Day12/k17.png)

and That's all we really need for now.Since we've done some work with testing we know that for testing, we could do our integration test on Kovan because there's an integration test there.But what about our local tests?Well this is something good that we're thinking about right now.We know that aave actually has all these "WETH" same contracts on the mainnet as well and we also know that we're not gonna be working with any oracles because that we don't actually have to deploy any mocks ourselves.We can if we want to but we don't have to.

What we can do is for our unit tests is we can just actually use Mainnet-fork network and just fork everything that's on the mainnet into our own local network.So instead of actually using mocks, we'll basically just mock the entire mainnet and one more time just so that we absolutely have it here.`If you're not woring with oracle's, you don't need to mock responses.We can just go ahead and use a mainnet fork to run our unit tests.If you're using oracles then it makes alot more sense to do to development the network where you can mock oracles and mock oracle responses.`


With this in mind we know that we're going to be doing alot of our tests on mainnet fork.We can go ahead and add a mainnet fork in the network and then we can just add the [mainnet weth token](https://etherscan.io/token/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2) for mainnet fork.

Remember absolutely positively if you want to double check that the contract address that you're working with is correct, I highly recommend you to do so because if you get it wrong, you could accidentally add some money to a contract address that you don't want.

![mainnetFork](/Images/Day12/k18.png)

And in our termianl we can do  `brownie networks list`.

![networkLists](/Images/Day12/k19.png)

We can that indeed we've a mainnet fork here.That's going to use the ganache-cli to fork mainnet for us.

Now that we've the interface we know that we can actually compile it down to the abi.So back in our get_Weth, first thing we need to do to make any transaction obviously is get an account.This is where we can go back and make our helpful scripts.

![helpful_scripts](/Images/Day12/k20.png)


We've our account where we can make some transactions with.Let's go ahead and get our WETH contract.To do this we can import interfaces fromm brownie.

![gettingContract](/Images/Day12/k21.png)

**Why not get_contract?**

You might be asking "Why aren't we using the get_contract function?"Well you can absolutely 100% go ahead and use that get_contract function but since we're gonna be testing on mainnet fork I know that we're always going to be refer back to the config.So I'm confident that I'm not going to be deploying any mocks.It's better practice to go ahead and use that get_contract function but for this one we'll just make it a little simpler and use the config.

For going to mainnet or for to real production, you could also have a mainnet network and it'll just be an exact copy of mainnet-fork.And remember we want our .env files our environment variables to get pulled from that .env file.

![config](/Images/Day12/k22.png)

Now everything in our .env file will pulled in automatically.Great we've an address and abi which comes from the interface.Now we can just call deposit function where we deposit ethereum and we get WETH.

![getWETH](/Images/Day12/k23.png)

Let's go ahead and run this script then.

`brownie run scripts/get_weth.py --network kovan`

![OutputWETH](/Images/Day12/k24.png)

We can use our transaction hash, pop into Kovan etherscan, you could see transaction going through.In our wallet we'll get -0.1 eth and we'll get +0.1 weth.To add this and see in our metamask, grab the contract address and add a token.

If you wanna switch back your WETH to ETH, you can just hit the withdraw function or you can programmatically add withdraw function.

![withdraw](/Images/Day12/k25.png)

Now we've ERC20 token "WETH" that we can use to interact with the aave appliction.Now that we've get_weth function let's go ahead and start borrowing.

**aave_borrow.py**

Let's go ahead and start with our account.

![get_Acc](/Images/Day12/k26.png)

We're gonna get WETH address or we can even just do our ERC20 address because the WETH token is in ERC20 and maybe we wanna deposit some other ERC20.

![ercAddress](/Images/Day12/k27.png)

And now we wanna call this get_weth function just in case we don't already have.We'll import get_weth from scripts but we don't actually need to call it right now because we already have some wrapped ethereum in our Kovan address.If you wanna test this though on our local mainnet-fork we probably will want to call this get_weth.So I'm just gonna add a little if statement.

When we call get_account in our scripts, it actually knows that it's a local environment that we're working with and it'll just return accounts[0].Instead of us having to actually load a private key in every single time and we want to actually wait for our transaction to complete in our get_weth function.

![getWeth](/Images/Day12/k28.png)

We can run `brownie run scripts/aave_borrow.py --network mainnet-fork`

![running_getWETH](/Images/Day12/k29.png)

Testing everything on mainnet-fork is going to give us a really accurate view of what doin this on mainnet actually is going to give us.We don't need to do any mocking.We can literally just fork all of mainnet and go from there.We're still gonna test on Kovan though in a little bit just so we can see all the transactions that go through, how long it takes for stuff to happen etc.

So now that we've got some weth, we actually need to go into our second bit.We're going to deposit some ETH in Aave.In our case some WETH.So how do we actually do that?

Well everything that we need is going to be in [Aave documentation](https://docs.aave.com/developers/getting-started/readme).

**Lending Pool**

Where we deposit and borrow from in Aave is in their contract LendingPool.It have all of the functions that we need.It has deposit where we deposit our asset as a collteral, withdraw where we take it back, borrow, repay and a couple other interesting ones which we'll go into later.But for now we just really need to focus on repaying, borrowing, withdrawing and depositing.So as you probably guessed deposit is the function that we're gonna work on right now.Since this is the contract that we're gonna work with, as always two things you need when working with a contract are gonna be the `ABI` and the address.So we're gonna get this lending pool contract.

**LendingPool Address Provider**

Something about this lending pool is that the lending pool address can actually change little bit depending on alot of different pieces.There's this address provider which gives us the address of a specific or particular market.If we go back to the [Aave UI](https://classic.aave.com/#/markets), there's actually different markets.

![Markets](/Images/Day12/k30.png)

There's different types of ways we can interact with aave.We're just gonna work with the basic Aave V2 because it's easily the most used on mainnet.As well as the address provider registry will give us so this address provider will give us the address of the lending pool for our market.If we want to go across different markets, we have to go to [address provider registry](https://docs.aave.com/developers/core-contracts/pooladdressesproviderregistry) to find it but the addresses in here don't change.There's just one function that we need to work with this is getLendingPool which will give us the address of the actual lending pool.

So don't let it confuse you too much.Basically all we're trying to do is we're saying where's aave located right now and aave has a contract that will always tell us where the main aave contracts are and that's this addresses provider.So This is another contract that we've to work with.

Again when we've a contract, we need ABI and address.So we can absolutely once again we could go ahead and use interface because life is great with an interface.If we know we're only gonna work with one or two functions, we can actually just make the interfaces ourself.So an interface, we could do new file and give it a name "ILendingPoolAddressProvider.sol" and we can just add it in here ourselves.

Tips: You don't need the whole interface.Just define the functions that you'll work with. 

![Interface](/Images/Day12/k31.png)

We know that there's only one function called getLendingPool and we're not exactly sure what getLendingPool is defined as but what we can do is we can go to [aave's github](https://github.com/aave/protocol-v2/blob/master/contracts/interfaces/ILendingPoolAddressesProvider.sol) where we can see:

![getLP](/Images/Day12/k32.png)

It's an external view and returns address.Let's make our getLendingPool the same.

![getLendingPool](/Images/Day12/k33.png)

We could run with this and this would work perfectly fine but this leads us to the next point we might just as well grab the whole thing.This way we know for fact we're not getting anything wrong.If we wanted to, our interface could be this only because this is going to compile down to an abi and the abi is gonna say "There's a function here."and that's all the abi is really doing.It's just telling us how we can interact with a contract but let's go ahead and everything so that if we want to interact with more things, we can.

So now we've the abi, we also now need an address which we can definitely find from the [aave documentation](https://docs.aave.com/developers/v/2.0/deployed-contracts/deployed-contracts).We're gonna find LendingPoolAddressProvider, copy that and put it in our brownie-config.

![lendingPoolAddress](/Images/Day12/k34.png)

Now that we've an abi and the address for both Kovan and mainnet-fork, what we can do now is first get the lending pool addresses provider from the interface.

![gettingLP](/Images/Day12/k35.png)

Then we want to return the address of the lendingPool.

![gettingLPaddress](/Images/Day12/k36.png)

Because the address provider has this getLendingPool which returns the address of the lending pool.Now that we've the address, we can actually return the lending pool contract by once again getting the abi and the address of the actual lending pool.So we have the address, we just need the abi which once again we can work with our wonderful interfaces "ILendingPool.sol".

There's only gonna be couple of functions we're going to work with but aave actually gives us the [interface](https://docs.aave.com/developers/v/2.0/the-core-protocol/lendingpool/ilendingpool).

**Fixing Importing Dependencies**

We do need to actually change one thing in ILendingPool.sol.This interface imports locally with `./`.So we actually just need to change these imports to actually import directly from github instead of importing locally.Luckily this is something we already know how to do.So let's go to our brownie-config.

![dependencies](/Images/Day12/k37.png)

This way brownie will download this right from github and now we can just use @aave instead.So back in our ILendingPool.sol, we can change `./` to 

![importingDep](/Images/Day12/k38.png)

Now we've actually imported this interface for us to use,we can go ahead and just compile just to make sure that everything is working correctly.

`brownie compile`

If these interfaces had an issue, they actually wouldn't compile through brownie.

Now that we've the interface, we know that these interfaces compile down to the abi and we already have the address.So to actually interact with the lending pool now.

![ReturningLP](/Images/Day12/k39.png)

Now we've a function that goes through the lending pool addresses provider from the aave documentation and returns the lending pool contract that we can now interact with.

Now that we've the actual address, what we're going to do now is we're gonna take this WETH that we've got this ERC20 version of Eth and we're going to deposit it into this contract just like what we did in the UI.In order to actually first deposit it, we need to approve this ERC20 token.

ERC20 tokens have an approve function that makes sure that whenever we send a token to somebody or whenever a token calls, a function that uses our tokens, we actually have given them permission to do so.So that's the first thing that we actually have to do is we're gonna have to approve sending our ERC20 tokens and this resembles so.Since I know we're going to have to approve alot, I'm actually just going to go ahead and make an approve ERC20 token function similar to what we did with the getLendingPool.

![approveERC](/Images/Day12/k40.png)

How do we actually call this approve function on a token contract?Well as always we're gonna need the abi and the address of the token contract.Now we could create our interface ourselves, looking at the functionalities of the ERC20 tokens or grab it from [here](https://github.com/PatrickAlphaC/aave_brownie_py_freecode/blob/main/interfaces/IERC20.sol).Copy everything and paste it inside IERC20.sol inside interfaces.So you can see number of different functions.We can check the allowance, balanceOf different addresses, how many decimals a token has, the name, the symbol, do some transfer and then the function that we're gonna be using is approve function.We can see the parameters the approve function takes.We're gonna need to have a spender and how much they can actually spend.So 

if we come back to approve_erc20, we know for input parameters are amount, spender address, erc20 token address and account.

![approve](/Images/Day12/k41.png)

So back up in our main function, we could call approve_erc20 for some amount, the spender is gonna be the lending_pool address, erc20_address and account.The only thing that we haven't defined right now is some amount which we can make it really whatever we wanna be.To keep things standard let's make it 0.1. 

![approveFunction](/Images/Day12/k42.png)

Now we can run `brownie run scripts/aave_borrow.py --network mainnet-fork`

We can see that our approve function is working as intended.It's annoying to do --network mainnet-fork so we'll change our default to mainnet-fork.

![default](/Images/Day12/k43.png)

Now we just need to deposit it into aave.Since we know we're probably gonna use this alot too, let's go ahead and create a deposit function.

**deposit function**

Since we've everything approved we can now go ahead and use the lending pool deposit method and we can check the [documentation](https://docs.aave.com/developers/v/2.0/the-core-protocol/lendingpool) to see what the parameters that it takes are.

![depositParameters](/Images/Day12/k44.png)

First thing is gonna be the address of the asset which we know is gonna be erc20_address, amount of the token, address onBehalfOf is just gonna be our account.address.We're depositing the collateral for ourselves and then referral code which is actually deprecated and workloads don't actually work anymore so we're always gonna be passing 0.

![deposit](/Images/Day12/k45.png)

Now we can run it to see if everything's working fine or not.

`brownie run scripts/aave_borrow.py`

If you get the `"SafeMath Substraction Overflow error"` then change the datatype of amount in ILendingPool.sol to int256 run the script.It'll run fine and again keep the datatype as it was before i.e uint256.

Now that we've some collateral deposited, we can go ahead and actually take out a borrow.We can go ahead and borrow some other asset.The question gonna be how much.How much can we actually borrow?How much should be borrow?What would result in positive health factor?

**getUserAccountData**

Maybe we should actually pull off chain some of our stats.How much do we actually have deposited?How much collateral we've?How much debt we've and so on and so forth.That way in the future when we don't start clean, we can take some inventory of where we stand with our collateral in our debts.

At the [aave documentation](https://docs.aave.com/developers/core-contracts/pool), we can go ahead and see the getUserAccountData function.This is going to return the user account data across all reserves.So it's gonna get the totalCollateralETH that we've deposited in terms of ethereum, total debt in terms of ETH, how much we can borrow: the borrowing power we have, liquidation threshold or how close to that liquidation threshold will be, loan to value ratio and again health factor.This health factor is obviously incredibly important because if it drops below 1 or reaches 1, users can call liquidation call.This function all these variables but for now we really only care about how much collateral we've, how much debt we've and how much we're available to borrow.So let's go ahead and write a function that will actually sort that for us.

![accPara](/Images/Day12/k46.png)

We're looking to call get_borrowable_data function on the lending pool from an account.So let's go ahead and call that function.

![lendingPool](/Images/Day12/k47.png)

If we look at the API, all that it needs is a user's address to get started and it return 6 variables.

![returningValues](/Images/Day12/k48.png)

getUserAccountData is a view function so we don't need to spend any gas.All of the variables are gonna be returned in terms of wei.So let's just go ahead and convert these from wei to something that makes a little bit more sense to us.

 ![get_borrowable_data](/Images/Day12/k49.png)
 
 The reason that we'd to add float variable is that without it some of the math that we're gonna try to later won't pan out.
 
 Now we've this function get_borrowable_data and we're gonna pass lending_pool and account.Since we're returning available_borrow_eth and the total_debt_eth, we do:
 
![gettingBorrowableData](/Images/Day12/k50.png)


Let's go ahead and try this out.

`brownie run scripts/aave_borrow.py`

We've deposited 0.1 worth of ETH, 0 ETH borrowed and we can borrow 0.08 worth of ETH.The maximum amount that you can borrow will always be less than your collateral.This is because of the `liquidation threshold`.

**liquidation threshold**

In the [risk parameters documentation](https://docs.aave.com/risk/asset-risk/risk-parameters), we can see different liquidation thresholds on different assets.We can see Ethereum has 80% loan to value(ltv).With Ethereum we can only borrow upto 80% of the deposit assets that we've.And If we have more than 82.5% borrowed, will actually get liquidated.It also tells about the liquidation bonus, reserve factor and some other helpful pieces.

**Borrowing DAI**

Now that we've this borrowble ETH amount, we can go ahead and actually borrow some DAI.

**Getting DAI conversion rate**

In order for us to borrow some DAI, we also need to get the conversion rate.We need to get DAI in terms of ETH.We're going to have to use some price feed here.Luckily we already know how to work with chainlink and how to get pricefeeds.Aave uses the chainlink pricefeeds as well.So we're using the exact same conversion rate tools that aave's gonna use.Let's create a function to get us the conversion rate.

![dai_rate](/Images/Day12/k51.png)

we passed the dai_eth_price_feed which will be the address of the dai ethereum conversion rate.Let's go ahead and create get_asset_price function.

First thing we're gonna need is this die_eth_price_feed address.Where can we get this?As we know per usual we'll head over to [chainlink documentation](https://docs.chain.link/docs/ethereum-addresses/), grab the address and paste it into our config for mainnet-fork and for Kovan as well.

![dai_ETH](/Images/Day12/k52.png)

and then we can get the address of the same way we got the address of the WETH token.

![gettingAddress](/Images/Day12/k53.png)

Now we've a way to change the price feed address depending on what network we're on.So in our get_asset_price function, we're gonna do the same exact thing that we always do.We're gonna grab an ABI and an address to work with the contract.Again we can get the ABI by just working directly with the [interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol).

![passing_address_inV3](/Images/Day12/k54.png)

Now the dai_eth_price_feed is gonna be a contract that we can call a function on.We can always refer back to [get the latest price documentation](https://docs.chain.link/docs/get-the-latest-price/) to see how to actually wort with it.Even simple python code is there for working with it in Web3.We're gonna go ahead and call latestRoundData function which we can also find in our AggregatorV3Interface which returns roundId, answer, startedAt, updatedAt and answeredInRound.All we're really concerned with is answer.The way we can do this is :

![gettingDaiETHPrice](/Images/Day12/k55.png)

So let's go ahead and run this:

`borwnie run scripts/aave_borrow.py`

We know that DAI/ETH price feed has 18 decimal place.The number that shown of the screen isn't the real price.The real price is divisible by 10**18.But this number is difficult to read.So what we can do is we can use the method of fromWei from Web3.

![ConvertedToEther](/Images/Day12/k56.png)

Now we've DAI/ETH price.We're getting really close to borrow this actual asset.Let's even return the converted_latest_price just so that we're always working in units that we understand.

Now we can calculate the amount of DAI that we want to borrow.

![AmountDai](/Images/Day12/k57.png)

And just to be safe we times it by 0.95 to make sure our health_factor is better.This line we're converting our borrowable eth to borrowable dai and then we're timsing it by 95%.We're timing it by 95% because we don't wanna get liquidated.Remember how we slid that sliding scale around to make it safer and less safe.Well the lower percentage that we actually borrow maybe we even borrow 50% of our collateral the safer that we're gonna be.Keep that in mind when you're deciding how much to actually borrow if you wanna run this in a production environment.

Finally we'll borrow now.Looking at the [aave documentation](https://docs.aave.com/developers/core-contracts/pool), we can look at their borrow function.Let's go ahead and call this function.

**Getting DAI address**

First we should get a DAI address which once again we'll want to put it in our config.We'll add the dai_token which we can find from [etherscan dai token](https://etherscan.io/token/0x6b175474e89094c44da98b954eedeac495271d0f?a=0x2faf487a4414fe77e2327f0bf4ae2a264a776ad2#writeContract).

![mainnetDAI](/Images/Day12/k58.png)

If you want to run this on Kovan you're also gonna need to have a DAI token for Kovan.

**Aave Testnet Token Addresses**

On testnets aave actually changes up where the tokens for it's testnets are actually going to be.So if we go to their documentation, we go to deployed contracts and we go to Kovan.

![KovanFlag](/Images/Day12/k59.png)

It's gonna be the same thing for tokens.And you can get the address of DAI from [here](https://docs.aave.com/developers/deployed-contracts/v3-testnet-addresses).

![configDAI](/Images/Day12/k60.png)

![dai_address](/Images/Day12/k61.png)


Now let's move on to the next parameter.The amount which we just figured in the code above but we do need to change it back to Wei.Then our interest rate mode which is gonna be either stable or variable.Stable is where the interest rate will always be exactly the same.Variable will change depending on alot of different things going on with aave.For safety we're just gonna go with stable.Then we're gonna do referral code and onBehalf.Referral code no longer exists so we'll pass 0 and it's gonna be on behalf of ourselves.

![borrowingDAI](/Images/Day12/k62.png)

If we've done this right we should have borrowed some DAI programmatically from the Aave protocol.And we can once again call our get_borrowable_data function since this function will print out our new account information for how much we've borrowed.

Let's go ahead and run this in our mainnet-fork again.If we've done this correctly we now see that we've borrowed some DAI.


**Repaying**

We've learned how to borrow everything which is fantastic.Let's go ahead and actually repay that back.So we're gonna call their repay function and we'll put it into their own function called repay_all and we'll give the amount that we want to repay, lending_pool address and our account.

So if we're gonna pay back first thing we need to do is actually call the approve function to prove that we're going to pay back.So we need to approve that erc20.

![Approve](/Images/Day12/k63.png)

Our ERC20 already calls wait so we don't have to call it.So once we approve we're gonna be using the DAI that we've borrowed to pay most of what we've borrowed back.Now we're going to call repay function.

![repayTxn](/Images/Day12/k64.png)

First we passed the asset that we're gonna use to repay, amount, the rate mode which we hard coded to 1 and the address on behalf of.

![repayAll](/Images/Day12/k65.png)

Let's see if this works:

`brownie run scripts/aave_borrow.py`

**Kovan Run**

If you want to what we can also do is we can see if this will work with our wallet address.What I can do is copy the address of the metamask, go to Kovan etherscan and test everything you'll run through the script.

You've essentially learned everything that we need to do through to become quantitative defi wizards and build really robust financial applications in the defi world.

**Testing**

Something I wanna point out.Even though this isn't a python course and we're learning more about solidity and smart contracts, it's still in your best interest to test these functions.Yes I know they're python functions but it's still gonna be in your best interest to test them to make sure your application always works as you expect it to.This is actually gonna be even easier than that lottery contract that we did since we're just testing python functions and we can test with `brownie tests`.  

![test1](/Images/Day12/k66.png)

![test2](/Images/Day12/k67.png)














































































 
 








 









